# Глава 71: Prompt Engineering для Трейдинга — Техники Оптимизации LLM

Эта глава рассматривает техники **Prompt Engineering**, специально разработанные для торговых приложений. Мы изучим, как создавать эффективные промпты, которые максимизируют точность и надёжность больших языковых моделей (LLM) для анализа настроений, генерации торговых сигналов, анализа рынка и автоматизированных торговых стратегий.

<p align="center">
<img src="https://i.imgur.com/8ZK9xPr.png" width="70%">
</p>

## Содержание

1. [Введение в Prompt Engineering](#введение-в-prompt-engineering)
    * [Что такое Prompt Engineering?](#что-такое-prompt-engineering)
    * [Почему Prompt Engineering важен для трейдинга](#почему-prompt-engineering-важен-для-трейдинга)
    * [Обзор ключевых техник](#обзор-ключевых-техник)
2. [Основы Prompt Engineering](#основы-prompt-engineering)
    * [Zero-Shot промптинг](#zero-shot-промптинг)
    * [Few-Shot промптинг](#few-shot-промптинг)
    * [Chain-of-Thought промптинг](#chain-of-thought-промптинг)
    * [Ролевой промптинг](#ролевой-промптинг)
3. [Финансовые шаблоны промптов](#финансовые-шаблоны-промптов)
    * [Промпты для анализа настроений](#промпты-для-анализа-настроений)
    * [Промпты для торговых сигналов](#промпты-для-торговых-сигналов)
    * [Промпты для оценки рисков](#промпты-для-оценки-рисков)
    * [Промпты для анализа рынка](#промпты-для-анализа-рынка)
4. [Продвинутые техники](#продвинутые-техники)
    * [Self-Consistency](#self-consistency)
    * [ReAct (Рассуждение + Действие)](#react-рассуждение--действие)
    * [Tree-of-Thought](#tree-of-thought)
    * [Цепочки промптов](#цепочки-промптов)
5. [Практические примеры](#практические-примеры)
    * [01: Анализ финансовых настроений](#01-анализ-финансовых-настроений)
    * [02: Генерация торговых сигналов](#02-генерация-торговых-сигналов)
    * [03: Определение рыночного режима](#03-определение-рыночного-режима)
    * [04: Бэктестинг с LLM сигналами](#04-бэктестинг-с-llm-сигналами)
6. [Реализация на Rust](#реализация-на-rust)
7. [Реализация на Python](#реализация-на-python)
8. [Лучшие практики](#лучшие-практики)
9. [Ресурсы](#ресурсы)

## Введение в Prompt Engineering

### Что такое Prompt Engineering?

Prompt engineering — это искусство и наука создания входных инструкций (промптов) для управления большими языковыми моделями с целью получения желаемых результатов. В торговых приложениях хорошо спроектированные промпты могут значительно улучшить качество инсайтов, генерируемых LLM.

```
РАБОЧИЙ ПРОЦЕСС PROMPT ENGINEERING:
┌──────────────────────────────────────────────────────────────────┐
│  СЫРОЙ ВВОД                                                       │
│  "Акции Apple выросли на 5% сегодня"                             │
└─────────────────────────┬────────────────────────────────────────┘
                          │
                          ▼
┌──────────────────────────────────────────────────────────────────┐
│  СПРОЕКТИРОВАННЫЙ ПРОМПТ                                          │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │ Вы финансовый аналитик, специализирующийся на              │  │
│  │ технологических акциях. Проанализируйте следующую новость: │  │
│  │ 1. Настроение (ПОЗИТИВНОЕ/НЕГАТИВНОЕ/НЕЙТРАЛЬНОЕ)          │  │
│  │ 2. Оценка уверенности (0-100)                               │  │
│  │ 3. Торговая рекомендация                                    │  │
│  │ 4. Ключевые факторы вашего анализа                          │  │
│  │                                                             │  │
│  │ Новость: "Акции Apple выросли на 5% сегодня"               │  │
│  └────────────────────────────────────────────────────────────┘  │
└─────────────────────────┬────────────────────────────────────────┘
                          │
                          ▼
┌──────────────────────────────────────────────────────────────────┐
│  СТРУКТУРИРОВАННЫЙ ВЫВОД                                          │
│  {                                                                │
│    "sentiment": "POSITIVE",                                       │
│    "confidence": 85,                                              │
│    "recommendation": "HOLD - ждите подтверждения",               │
│    "factors": ["Ценовой импульс", "Катализатор не указан"]       │
│  }                                                                │
└──────────────────────────────────────────────────────────────────┘
```

### Почему Prompt Engineering важен для трейдинга

Финансовый трейдинг представляет уникальные вызовы для LLM:

```
СПЕЦИФИЧЕСКИЕ ВЫЗОВЫ ТРЕЙДИНГА:
┌──────────────────────────────────────────────────────────────────┐
│  1. ТРЕБОВАНИЯ К ТОЧНОСТИ                                         │
│     Торговые решения требуют точных чисел, а не размытых оценок  │
│     Плохо: "Акция может вырасти"                                 │
│     Хорошо: "85% вероятность роста на 2-3% в течение 24 часов"   │
├──────────────────────────────────────────────────────────────────┤
│  2. ВРЕМЕННАЯ ЧУВСТВИТЕЛЬНОСТЬ                                    │
│     Финансовый контекст быстро меняется                          │
│     - "Ставки высокие" означает разное в 2000 и 2024 году        │
│     - "Рынок рухнул" требует указания конкретной даты            │
├──────────────────────────────────────────────────────────────────┤
│  3. ПРОФЕССИОНАЛЬНЫЙ ЖАРГОН                                       │
│     Финансовая терминология требует точного понимания            │
│     - "Бычья дивергенция" vs "Медвежья дивергенция"              │
│     - "Расширение P/E" vs "Сжатие мультипликатора"               │
├──────────────────────────────────────────────────────────────────┤
│  4. РИСК ГАЛЛЮЦИНАЦИЙ                                             │
│     LLM могут генерировать правдоподобные, но неверные данные    │
│     - Выдуманные цены акций или показатели прибыли               │
│     - Сфабрикованные рекомендации аналитиков                     │
├──────────────────────────────────────────────────────────────────┤
│  5. ИСПОЛНИМЫЙ ВЫВОД                                              │
│     Трейдингу нужны чёткие, исполнимые рекомендации              │
│     - Точки входа/выхода, размеры позиций                        │
│     - Уровни стоп-лосса и тейк-профита                           │
└──────────────────────────────────────────────────────────────────┘
```

### Обзор ключевых техник

| Техника | Лучше всего для | Сложность |
|---------|----------------|-----------|
| Zero-Shot | Простая классификация | Низкая |
| Few-Shot | Консистентный формат вывода | Средняя |
| Chain-of-Thought | Сложные рассуждения | Средняя |
| Ролевой | Экспертиза в предметной области | Низкая |
| Self-Consistency | Критически важные решения | Высокая |
| ReAct | Многошаговый анализ | Высокая |
| Tree-of-Thought | Стратегическое планирование | Очень высокая |

## Основы Prompt Engineering

### Zero-Shot промптинг

Zero-shot промптинг предоставляет инструкции без примеров. Он полагается на предобученные знания LLM.

```python
# Пример: Zero-shot анализ настроений
zero_shot_prompt = """
Проанализируйте настроение следующей финансовой новости.
Ответьте только: ПОЗИТИВНОЕ, НЕГАТИВНОЕ или НЕЙТРАЛЬНОЕ

Новость: "{news_text}"

Настроение:
"""

# Использование
news = "Tesla сообщила о рекордных квартальных поставках, превысив ожидания аналитиков на 15%"
# Ожидаемый вывод: ПОЗИТИВНОЕ
```

**Преимущества:**
- Простота реализации
- Не требует примеров
- Быстрая итерация

**Ограничения:**
- Меньший контроль над форматом вывода
- Может быть непоследовательным
- Плохо справляется со сложными задачами

### Few-Shot промптинг

Few-shot промптинг включает примеры для направления LLM к желаемому формату вывода и поведению.

```python
# Пример: Few-shot анализ настроений для трейдинга
few_shot_prompt = """
Проанализируйте настроение финансовой новости и предоставьте торговый сигнал.

Примеры:

Новость: "Apple превысила ожидания по прибыли благодаря сильным продажам iPhone"
Анализ: {
  "sentiment": "POSITIVE",
  "confidence": 92,
  "signal": "BUY",
  "reasoning": "Превышение прибыли обычно ведёт к росту цены на 2-5%"
}

Новость: "FDA отклонила заявку на лекарство от Pfizer"
Анализ: {
  "sentiment": "NEGATIVE",
  "confidence": 88,
  "signal": "SELL",
  "reasoning": "Отклонение лекарства существенно влияет на стоимость пайплайна"
}

Новость: "Microsoft объявила о дроблении акций в следующем месяце"
Анализ: {
  "sentiment": "NEUTRAL",
  "confidence": 75,
  "signal": "HOLD",
  "reasoning": "Дробление акций — механическое действие, без фундаментальных изменений"
}

Теперь проанализируйте эту новость:
Новость: "{news_text}"
Анализ:
"""
```

**Лучшие практики для Few-Shot:**
1. Используйте 3-5 разнообразных примеров
2. Включайте пограничные случаи
3. Поддерживайте единый формат
4. Покройте все категории вывода

### Chain-of-Thought промптинг

Chain-of-Thought (CoT) промптинг поощряет пошаговые рассуждения, что критически важно для сложного финансового анализа.

```python
# Пример: Chain-of-Thought для торгового решения
cot_prompt = """
Пошагово проанализируйте следующую рыночную ситуацию для определения оптимального торгового действия.

Рыночные данные:
- Актив: {symbol}
- Текущая цена: ${current_price}
- Изменение за 24ч: {change_24h}%
- Объём: {volume} (vs среднее за 20 дней: {volume_ratio}x)
- RSI(14): {rsi}
- Новость: "{news_headline}"

Рассуждайте пошагово:

Шаг 1: Оцените ценовое движение
- Что говорит нам изменение за 24ч о моментуме?
- Как это соотносится с типичными дневными движениями?

Шаг 2: Оцените объём
- Подтверждает ли объём ценовое движение?
- Высокий объём при росте = бычье подтверждение

Шаг 3: Проверьте технические индикаторы
- RSI > 70 указывает на перекупленность
- RSI < 30 указывает на перепроданность

Шаг 4: Учтите новостное настроение
- Как новость может повлиять на будущую цену?
- Уже ли движение заложено в цену?

Шаг 5: Синтезируйте и примите решение
- Объедините все факторы
- Определите уровень уверенности
- Предоставьте конкретную рекомендацию

Финальный анализ:
"""
```

**Преимущества CoT для трейдинга:**
- Заставляет проводить систематический анализ
- Раскрывает логику для проверки
- Снижает импульсивные сигналы
- Позволяет бэктестить логику

### Ролевой промптинг

Ролевой промптинг назначает LLM конкретную персону для использования экспертизы в предметной области.

```python
# Пример: Ролевые промпты для разных стилей торговли
role_prompts = {
    "quant_analyst": """
Вы количественный аналитик в ведущем хедж-фонде с 15-летним опытом.
Ваш стиль анализа:
- Ориентирован на данные, скептичен к нарративам
- Фокус на статистической значимости
- Риск-скорректированная доходность важнее абсолютной
- Всегда учитывайте размер позиции и корреляцию
""",

    "technical_trader": """
Вы профессиональный технический аналитик, специализирующийся на крипторынках.
Ваш стиль анализа:
- Ценовое действие и объём — главные факторы
- Уровни поддержки/сопротивления ключевые
- Следование за трендом с подтверждением моментума
- Строгая дисциплина стоп-лоссов
""",

    "fundamental_analyst": """
Вы фундаментальный аналитик, фокусирующийся на долгосрочном стоимостном инвестировании.
Ваш стиль анализа:
- Качество и устойчивость прибыли
- Анализ конкурентного рва
- Послужной список менеджмента
- Маржа безопасности обязательна
""",

    "risk_manager": """
Вы старший риск-менеджер на институциональном торговом деске.
Ваш стиль анализа:
- Максимальная просадка — главная забота
- Корреляционный и концентрационный риск
- Хвостовой риск и события "чёрного лебедя"
- Лимиты позиций и VaR портфеля
"""
}
```

## Финансовые шаблоны промптов

### Промпты для анализа настроений

```python
# Шаблон: Комплексный анализ настроений
SENTIMENT_TEMPLATE = """
Вы анализируете финансовые новости для торговых сигналов.

НОВОСТНАЯ СТАТЬЯ:
"{article_text}"

Проанализируйте эту статью и предоставьте:

1. ОБЩЕЕ НАСТРОЕНИЕ
   - Классификация: [БЫЧЬЕ | МЕДВЕЖЬЕ | НЕЙТРАЛЬНОЕ]
   - Уверенность: [0-100]%
   - Обоснование: [Краткое объяснение]

2. НАСТРОЕНИЕ ПО СУЩНОСТЯМ
   Для каждой упомянутой компании/актива:
   - Сущность: [Название/Тикер]
   - Настроение: [БЫЧЬЕ | МЕДВЕЖЬЕ | НЕЙТРАЛЬНОЕ]
   - Уровень влияния: [ВЫСОКИЙ | СРЕДНИЙ | НИЗКИЙ]

3. ВРЕМЕННОЙ АНАЛИЗ
   - Краткосрочное влияние (1-5 дней): [Описание]
   - Среднесрочное влияние (1-4 недели): [Описание]
   - Уже заложено в цену: [ДА | НЕТ | ЧАСТИЧНО]

4. ТОРГОВЫЕ ПОСЛЕДСТВИЯ
   - Основной сигнал: [ПОКУПАТЬ | ПРОДАВАТЬ | ДЕРЖАТЬ]
   - Рекомендуемый вход: [Немедленно | Ждать откат | Ждать подтверждение]
   - Уровень риска: [ВЫСОКИЙ | СРЕДНИЙ | НИЗКИЙ]

Ответьте в формате JSON.
"""
```

### Промпты для торговых сигналов

```python
# Шаблон: Генерация торгового сигнала
SIGNAL_TEMPLATE = """
Вы систематический генератор торговых сигналов.

РЫНОЧНЫЙ КОНТЕКСТ:
- Актив: {symbol}
- Таймфрейм: {timeframe}
- Текущая цена: ${price}
- Рыночный режим: {regime}

ТЕХНИЧЕСКИЕ ДАННЫЕ:
- Тренд (50 SMA): {trend_direction}
- Моментум (RSI): {rsi}
- Волатильность (ATR%): {atr_percent}%
- Тренд объёма: {volume_trend}

ФУНДАМЕНТАЛЬНЫЕ ДАННЫЕ:
- Коэффициент P/E: {pe_ratio}
- Сюрприз по прибыли (последний): {earnings_surprise}%
- Консенсус аналитиков: {analyst_rating}

ДАННЫЕ НАСТРОЕНИЙ:
- Новостное настроение (24ч): {news_sentiment}
- Социальное настроение: {social_sentiment}
- Институциональные потоки: {inst_flow}

Сгенерируйте торговый сигнал:

1. СИГНАЛ
   - Направление: [LONG | SHORT | FLAT]
   - Сила: [СИЛЬНЫЙ | УМЕРЕННЫЙ | СЛАБЫЙ]
   - Уверенность: [0-100]%

2. ВХОД
   - Тип: [MARKET | LIMIT]
   - Цена (если LIMIT): $___
   - Размер (% от портфеля): ___

3. ПЛАН ВЫХОДА
   - Тейк-профит 1: $___ (___% позиции)
   - Тейк-профит 2: $___ (___% позиции)
   - Стоп-лосс: $___
   - Трейлинг стоп: [ДА/НЕТ] на ___% ATR

4. ОБОСНОВАНИЕ
   [Объяснение сигнала в 2-3 предложениях]

5. ОЦЕНКА РИСКА
   - Макс. убыток: $___
   - Соотношение риск/прибыль: ___
   - Ключевые риски: [Список основных рисков]

Вывод в JSON.
"""
```

### Промпты для оценки рисков

```python
# Шаблон: Оценка рисков портфеля
RISK_TEMPLATE = """
Вы специалист по управлению рисками, оценивающий риски портфеля.

ТЕКУЩИЙ ПОРТФЕЛЬ:
{portfolio_positions}

РЫНОЧНЫЕ УСЛОВИЯ:
- Уровень VIX: {vix}
- Рыночный тренд: {market_trend}
- Корреляционный режим: {correlation_regime}
- Ключевые предстоящие события: {upcoming_events}

Проведите комплексную оценку рисков:

1. РИСК НА УРОВНЕ ПОЗИЦИЙ
   Для каждой позиции оцените:
   - Концентрационный риск (% портфеля)
   - Риск ликвидности (дней на выход)
   - Специфические факторы риска

2. РИСК НА УРОВНЕ ПОРТФЕЛЯ
   - Общая рыночная экспозиция (бета)
   - Секторная концентрация
   - Географическая концентрация
   - Факторные экспозиции

3. СЦЕНАРНЫЙ АНАЛИЗ
   Оцените влияние на портфель при:
   - Обвал рынка (-20%): ___% потери портфеля
   - Ротация секторов: ___% влияние на портфель
   - Шок процентных ставок (+100bps): ___% влияние
   - Событие "чёрного лебедя": Худший сценарий потерь

4. РЕКОМЕНДАЦИИ
   - Позиции для сокращения: [Список]
   - Хеджи для рассмотрения: [Список]
   - Пробелы в диверсификации: [Список]
   - Приоритетные действия: [Ранжированный список]

5. МЕТРИКИ РИСКА
   - VaR портфеля (95%, 1 день): $___
   - Ожидаемый дефицит: $___
   - Максимальная просадка (историческая): ____%
   - Коэффициент Шарпа: ___

Предоставьте детальный JSON вывод.
"""
```

### Промпты для анализа рынка

```python
# Шаблон: Определение рыночного режима
REGIME_TEMPLATE = """
Вы анализируете текущие рыночные условия для определения рыночного режима.

РЫНОЧНЫЕ ДАННЫЕ:
- S&P 500: {sp500_price} ({sp500_change}% за месяц)
- VIX: {vix}
- 10-летние казначейские: {treasury_10y}%
- Индекс доллара (DXY): {dxy}
- Сырая нефть: ${oil}
- Золото: ${gold}

ИНДИКАТОРЫ ШИРОТЫ:
- Рост/Падение: {adv_dec_ratio}
- % выше 200 SMA: {pct_above_200sma}%
- Новые максимумы - Новые минимумы: {high_low_diff}

МЕЖРЫНОЧНЫЕ СИГНАЛЫ:
- Корреляция акции/облигации: {stock_bond_corr}
- Корреляция доллар/акции: {dollar_equity_corr}

Классифицируйте текущий рыночный режим:

1. КЛАССИФИКАЦИЯ РЕЖИМА
   Выберите один:
   - RISK_ON_TRENDING: Сильный восходящий тренд, низкая волатильность
   - RISK_ON_VOLATILE: Восходящий тренд с высокой волатильностью
   - RISK_OFF_TRENDING: Сильный нисходящий тренд, растущая волатильность
   - RISK_OFF_PANIC: Режим краха, экстремальный страх
   - RANGING: Боковое движение, низкая уверенность
   - TRANSITIONAL: Смена режима в процессе

2. УВЕРЕННОСТЬ: [0-100]%

3. КЛЮЧЕВЫЕ ДРАЙВЕРЫ
   [Перечислите 3-5 факторов, определяющих текущий режим]

4. ИСТОРИЧЕСКАЯ АНАЛОГИЯ
   [Наиболее похожий исторический период и что произошло дальше]

5. ПРОГНОЗ РЕЖИМА
   - Ожидаемая продолжительность: [Дни/Недели/Месяцы]
   - Вероятный следующий режим: [Название режима]
   - Триггеры перехода: [На что смотреть]

6. СТРАТЕГИЧЕСКИЕ ПОСЛЕДСТВИЯ
   - Рекомендуемые стратегии: [Список]
   - Стратегии для избегания: [Список]
   - Корректировка размера позиций: [Увеличить/Уменьшить/Сохранить]

Вывод в JSON.
"""
```

## Продвинутые техники

### Self-Consistency

Self-consistency улучшает надёжность путём генерации нескольких ответов и их агрегации.

```python
# Пример: Self-consistency для торговых сигналов
import json
from typing import List, Dict
import asyncio

async def self_consistent_analysis(
    prompt: str,
    llm_client,
    num_samples: int = 5,
    temperature: float = 0.7
) -> Dict:
    """
    Генерирует несколько анализов и агрегирует для согласованности.

    Args:
        prompt: Промпт для анализа
        llm_client: Клиент LLM API
        num_samples: Количество независимых выборок
        temperature: Температура сэмплирования (выше = разнообразнее)

    Returns:
        Агрегированный анализ с уверенностью
    """
    # Генерация нескольких выборок
    tasks = [
        llm_client.complete(prompt, temperature=temperature)
        for _ in range(num_samples)
    ]
    responses = await asyncio.gather(*tasks)

    # Парсинг ответов
    analyses = []
    for response in responses:
        try:
            analysis = json.loads(response)
            analyses.append(analysis)
        except json.JSONDecodeError:
            continue

    if not analyses:
        return {"error": "Нет валидных ответов"}

    # Агрегация результатов
    signals = [a.get("signal", "HOLD") for a in analyses]
    confidences = [a.get("confidence", 50) for a in analyses]

    # Мажоритарное голосование для сигнала
    signal_counts = {}
    for signal in signals:
        signal_counts[signal] = signal_counts.get(signal, 0) + 1

    majority_signal = max(signal_counts, key=signal_counts.get)
    agreement_ratio = signal_counts[majority_signal] / len(signals)

    # Корректировка уверенности на основе согласия
    avg_confidence = sum(confidences) / len(confidences)
    final_confidence = avg_confidence * agreement_ratio

    return {
        "signal": majority_signal,
        "confidence": final_confidence,
        "agreement_ratio": agreement_ratio,
        "sample_count": len(analyses),
        "individual_signals": signals,
        "reasoning_samples": [a.get("reasoning", "") for a in analyses[:3]]
    }
```

### ReAct (Рассуждение + Действие)

ReAct объединяет рассуждения с действиями, позволяя многошаговый анализ с использованием инструментов.

```python
# Пример: Паттерн ReAct для исследования рынка
REACT_TEMPLATE = """
Вы торговый аналитик, который может исследовать и анализировать рынки.

Доступные инструменты:
- get_price(symbol): Получить текущую цену и дневное изменение
- get_news(symbol, days): Получить недавние заголовки новостей
- get_technicals(symbol): Получить технические индикаторы
- get_fundamentals(symbol): Получить фундаментальные метрики
- calculate_position_size(symbol, risk_pct): Рассчитать размер позиции

Задача: {task}

Используйте следующий формат:

Мысль: [Ваши рассуждения о том, что делать дальше]
Действие: [Название инструмента и параметры]
Наблюдение: [Результат инструмента]
... (повторяйте Мысль/Действие/Наблюдение по необходимости)
Мысль: У меня теперь достаточно информации для финального ответа
Финальный ответ: [Ваш полный анализ и рекомендация]

Начните!

Мысль:
"""
```

### Tree-of-Thought

Tree-of-Thought исследует множественные пути рассуждений для сложных стратегических решений.

```python
# Пример: Tree-of-Thought для распределения портфеля
TREE_OF_THOUGHT_TEMPLATE = """
Вы оптимизируете решение по распределению портфеля.

СЦЕНАРИЙ:
{scenario_description}

ОГРАНИЧЕНИЯ:
- Макс. размер позиции: {max_position}%
- Макс. секторная концентрация: {max_sector}%
- Целевая волатильность: {target_vol}%
- Частота ребалансировки: {rebalance_freq}

Исследуйте ТРИ разные стратегии распределения:

СТРАТЕГИЯ A: Консервативная
- Философия: [Опишите подход]
- Распределение: [Детализируйте позиции]
- Ожидаемая доходность: [Оценка]
- Ожидаемый риск: [Оценка]
- Ключевое допущение: [Что должно быть верно для успеха]

СТРАТЕГИЯ B: Умеренная
- Философия: [Опишите подход]
- Распределение: [Детализируйте позиции]
- Ожидаемая доходность: [Оценка]
- Ожидаемый риск: [Оценка]
- Ключевое допущение: [Что должно быть верно для успеха]

СТРАТЕГИЯ C: Агрессивная
- Философия: [Опишите подход]
- Распределение: [Детализируйте позиции]
- Ожидаемая доходность: [Оценка]
- Ожидаемый риск: [Оценка]
- Ключевое допущение: [Что должно быть верно для успеха]

ОЦЕНКА:
Сравните стратегии по:
1. Риск-скорректированная доходность (коэффициент Шарпа)
2. Защита от падения
3. Устойчивость к нарушению допущений
4. Сложность реализации

РЕКОМЕНДАЦИЯ:
[Выберите лучшую стратегию с детальным обоснованием]

ГИБРИДНЫЙ ВАРИАНТ:
[Предложите комбинацию, берущую лучшие элементы из каждой]
"""
```

### Цепочки промптов

Цепочки промптов разбивают сложный анализ на последовательные специализированные промпты.

```python
# Пример: Цепочка промптов для торгового решения
class TradingPromptChain:
    """
    Многошаговая цепочка промптов для комплексного торгового анализа.

    Цепочка: Анализ данных → Оценка рисков → Генерация сигнала → План исполнения
    """

    PROMPTS = {
        "data_analysis": """
Проанализируйте следующие рыночные данные для {symbol}:

Ценовые данные: {price_data}
Данные объёма: {volume_data}
Технические индикаторы: {technicals}

Предоставьте:
1. Анализ тренда (короткий/средний/длинный срок)
2. Ключевые уровни поддержки/сопротивления
3. Анализ объёма
4. Аномалии или примечательные паттерны

Вывод в JSON с ключами: trend, levels, volume, patterns
""",

        "risk_assessment": """
На основе следующего анализа данных:
{data_analysis_result}

Текущий контекст портфеля:
{portfolio_context}

Оцените риск открытия позиции в {symbol}:
1. Риски конкретной позиции
2. Влияние на портфель
3. Риск тайминга рынка
4. Максимальный рекомендуемый размер позиции

Вывод в JSON с ключами: risks, portfolio_impact, timing_risk, max_size
""",

        "signal_generation": """
Дано:
- Анализ данных: {data_analysis_result}
- Оценка рисков: {risk_assessment_result}
- Рыночный режим: {market_regime}

Сгенерируйте торговый сигнал для {symbol}:
1. Направление сигнала (LONG/SHORT/FLAT)
2. Уровень уверенности (0-100)
3. Условия входа
4. Подтверждающие факторы
5. Противоречащие факторы

Вывод в JSON с ключами: signal, confidence, entry, pros, cons
""",

        "execution_plan": """
Торговый сигнал: {signal_result}
Параметры риска: {risk_assessment_result}
Текущая цена: {current_price}

Создайте детальный план исполнения:
1. Метод входа (market/limit/scaled)
2. Расчёт размера позиции
3. Размещение стоп-лосса
4. Цели тейк-профита
5. Правила управления позицией
6. Триггеры выхода

Вывод в JSON с ключами: entry, size, stop_loss, take_profit, management, exit_triggers
"""
    }

    async def execute(self, symbol: str, market_data: Dict, llm_client) -> Dict:
        """Выполнить полную цепочку промптов."""
        results = {}

        # Шаг 1: Анализ данных
        prompt1 = self.PROMPTS["data_analysis"].format(
            symbol=symbol,
            price_data=market_data["price"],
            volume_data=market_data["volume"],
            technicals=market_data["technicals"]
        )
        results["data_analysis"] = await llm_client.complete(prompt1)

        # Шаг 2: Оценка рисков
        prompt2 = self.PROMPTS["risk_assessment"].format(
            data_analysis_result=results["data_analysis"],
            portfolio_context=market_data["portfolio"],
            symbol=symbol
        )
        results["risk_assessment"] = await llm_client.complete(prompt2)

        # Шаг 3: Генерация сигнала
        prompt3 = self.PROMPTS["signal_generation"].format(
            data_analysis_result=results["data_analysis"],
            risk_assessment_result=results["risk_assessment"],
            market_regime=market_data["regime"],
            symbol=symbol
        )
        results["signal"] = await llm_client.complete(prompt3)

        # Шаг 4: План исполнения
        prompt4 = self.PROMPTS["execution_plan"].format(
            signal_result=results["signal"],
            risk_assessment_result=results["risk_assessment"],
            current_price=market_data["price"]["current"]
        )
        results["execution_plan"] = await llm_client.complete(prompt4)

        return results
```

## Практические примеры

Полные примеры кода находятся в папках [python/](python/) и [rust/](rust/).

### 01: Анализ финансовых настроений

```python
# python/01_sentiment_analysis.py

class FinancialSentimentAnalyzer:
    """
    Анализатор финансовых настроений на основе prompt engineering.

    Использует тщательно разработанные промпты для извлечения
    торгово-релевантных настроений из финансового текста.
    """

    async def analyze(self, text: str) -> SentimentResult:
        """Анализ настроения финансового текста."""
        prompt = self.prompt_template.format(text=text)
        response = await self.llm.complete(prompt, temperature=0.3)
        return self._parse_response(response)
```

### 02: Генерация торговых сигналов

```python
# python/02_signal_generator.py

class PromptBasedSignalGenerator:
    """
    Генерация торговых сигналов с использованием engineered промптов.

    Комбинирует несколько техник промптинга:
    - Ролевой (персона quant-аналитика)
    - Chain-of-thought (систематические рассуждения)
    - Few-shot (консистентность формата вывода)
    """

    async def generate_signal(self, symbol: str, market_data: Dict) -> TradingSignal:
        """Генерация торгового сигнала из рыночных данных."""
        prompt = self._build_prompt(symbol, market_data)
        response = await self.llm.complete(prompt, temperature=0.2)
        return self._parse_signal(response)
```

### 03: Определение рыночного режима

```python
# python/03_regime_detection.py

class MarketRegimeDetector:
    """
    Определение рыночных режимов с использованием LLM анализа.

    Комбинирует количественные индикаторы с LLM рассуждениями
    для надёжной классификации режимов.
    """

    async def detect_regime(self, market_data: Dict) -> RegimeAnalysis:
        """Определить текущий рыночный режим."""
        prompt = self.REGIME_PROMPT.format(**market_data)
        response = await self.llm.complete(prompt, temperature=0.3)
        return self._parse_response(response)
```

### 04: Бэктестинг с LLM сигналами

```python
# python/04_backtest.py

class LLMSignalBacktester:
    """
    Бэктестинг торговых сигналов, генерируемых LLM анализом.

    Обрабатывает уникальные характеристики LLM-сигналов:
    - Переменные уровни уверенности
    - Размер позиции на основе рассуждений
    - Затухание сигнала во времени
    """

    def run_backtest(
        self,
        signals: pd.DataFrame,
        prices: pd.DataFrame
    ) -> BacktestResult:
        """Запустить бэктест на LLM-генерируемых сигналах."""
        # Реализация бэктеста...
        return BacktestResult(returns, equity_curve, trades, metrics)
```

## Реализация на Rust

См. [rust/](rust/) для полной реализации на Rust с асинхронной обработкой промптов.

```
rust/
├── Cargo.toml
├── README.md
├── src/
│   ├── lib.rs              # Основные экспорты библиотеки
│   ├── prompts/            # Шаблоны промптов
│   ├── llm/                # LLM клиент
│   ├── analysis/           # Модули анализа
│   └── backtest/           # Движок бэктестинга
└── examples/
    ├── sentiment.rs
    ├── signals.rs
    └── backtest.rs
```

### Быстрый старт (Rust)

```bash
cd rust

# Запуск примера анализа настроений
cargo run --example sentiment

# Генерация торговых сигналов
cargo run --example signals -- --symbol BTCUSDT

# Запуск бэктеста
cargo run --example backtest -- --start 2024-01-01 --end 2024-06-30
```

## Реализация на Python

См. [python/](python/) для полной реализации на Python.

```
python/
├── __init__.py
├── sentiment_analysis.py
├── signal_generator.py
├── regime_detection.py
├── backtest.py
├── prompts/
├── llm_client.py
├── data_loader.py
├── requirements.txt
└── examples/
```

### Быстрый старт (Python)

```bash
cd python

# Установка зависимостей
pip install -r requirements.txt

# Запуск анализа настроений
python examples/01_sentiment_demo.py

# Генерация сигналов
python examples/02_signal_generation.py --symbol BTCUSDT

# Запуск бэктеста
python examples/04_full_backtest.py --capital 100000
```

## Лучшие практики

### Рекомендации по дизайну промптов

1. **Будьте конкретны в формате вывода**
   ```python
   # Плохо: "Проанализируйте эту новость"
   # Хорошо: "Проанализируйте и ответьте в JSON с ключами: sentiment, confidence, reasoning"
   ```

2. **Включайте доменный контекст**
   ```python
   # Плохо: "Это позитивно или негативно?"
   # Хорошо: "Как финансовый аналитик, классифицируйте торговое настроение..."
   ```

3. **Используйте консистентные примеры**
   ```python
   # Используйте 3-5 разнообразных примеров, покрывающих пограничные случаи
   # Поддерживайте идентичный формат во всех примерах
   ```

4. **Ограничивайте числовой вывод**
   ```python
   # Плохо: "Оцените вашу уверенность"
   # Хорошо: "Уверенность (целое число 0-100):"
   ```

5. **Запрашивайте обоснование**
   ```python
   # Всегда просите обоснование для проверки логики
   # Позволяет пост-анализ и улучшение
   ```

### Частые ошибки, которых стоит избегать

1. **Размытые инструкции**
   - LLM интерпретируют неоднозначность непоследовательно
   - Будьте явными о каждом ожидаемом выводе

2. **Отсутствие обработки ошибок**
   - LLM могут выводить некорректный JSON или неожиданные значения
   - Всегда валидируйте и предоставляйте fallback-значения

3. **Чрезмерная зависимость от одного ответа**
   - Используйте self-consistency для критических решений
   - Несколько выборок снижают дисперсию

4. **Игнорирование контекстного окна**
   - Длинные промпты могут обрезать важную информацию
   - Суммаризируйте данные при необходимости

5. **Статические промпты**
   - Рыночные условия меняются; промпты должны эволюционировать
   - A/B тестируйте вариации промптов

### Оптимизация производительности

```python
# Советы для production prompt engineering

1. **Кэшируйте эмбеддинги**
   # Переиспользуйте эмбеддинги для похожих запросов

2. **Пакетные запросы**
   # Обрабатывайте несколько анализов в одном API вызове

3. **Асинхронная обработка**
   # Используйте async/await для параллельной генерации сигналов

4. **Сжатие промптов**
   # Удаляйте ненужные токены, сохраняя смысл

5. **Настройка температуры**
   # Ниже (0.1-0.3) для консистентных сигналов
   # Выше (0.5-0.7) для разнообразного анализа
```

## Ресурсы

### Научные статьи

- [A Survey on In-context Learning](https://arxiv.org/abs/2301.00234) — Комплексный обзор техник промптинга (2023)
- [Chain-of-Thought Prompting](https://arxiv.org/abs/2201.11903) — Оригинальная статья CoT от Google (2022)
- [Self-Consistency Improves Chain of Thought Reasoning](https://arxiv.org/abs/2203.11171) — Техника self-consistency (2023)
- [ReAct: Synergizing Reasoning and Acting](https://arxiv.org/abs/2210.03629) — Фреймворк ReAct (2023)
- [Tree of Thoughts](https://arxiv.org/abs/2305.10601) — ToT для осознанного решения проблем (2023)
- [FinGPT: Financial LLMs](https://arxiv.org/abs/2306.06031) — Open-source финансовая LLM (2023)

### Инструменты и библиотеки

| Инструмент | Описание | Ссылка |
|------------|----------|--------|
| LangChain | Фреймворк для LLM приложений | [langchain.com](https://langchain.com) |
| OpenAI API | Модели GPT-4 и эмбеддинги | [platform.openai.com](https://platform.openai.com) |
| Anthropic API | Модели Claude | [anthropic.com](https://anthropic.com) |
| Ollama | Запуск LLM локально | [ollama.ai](https://ollama.ai) |

### Связанные главы

- [Глава 61: FinGPT Financial LLM](../61_fingpt_financial_llm) — Open-source финансовая LLM
- [Глава 66: Chain-of-Thought для трейдинга](../66_chain_of_thought_trading) — Углублённое изучение CoT
- [Глава 67: LLM Sentiment Analysis](../67_llm_sentiment_analysis) — Анализ настроений
- [Глава 62: BloombergGPT](../62_bloomberggpt_trading) — Доменно-специфичная LLM
- [Глава 65: RAG для трейдинга](../65_rag_for_trading) — Retrieval-augmented generation

---

## Уровень сложности

**Средний - Продвинутый**

Предварительные требования:
- Понимание LLM и архитектуры трансформеров
- Опыт программирования на Python
- Базовые знания трейдинга (сигналы, бэктестинг)
- Опыт интеграции с API

## Литература

1. Brown, T., et al. (2020). "Language Models are Few-Shot Learners." NeurIPS.
2. Wei, J., et al. (2022). "Chain-of-Thought Prompting Elicits Reasoning in Large Language Models."
3. Wang, X., et al. (2023). "Self-Consistency Improves Chain of Thought Reasoning."
4. Yao, S., et al. (2023). "ReAct: Synergizing Reasoning and Acting in Language Models."
5. Yao, S., et al. (2023). "Tree of Thoughts: Deliberate Problem Solving with Large Language Models."
6. Yang, H., et al. (2023). "FinGPT: Open-Source Financial Large Language Models."

"""
LLM Signal Backtesting Engine

This module provides backtesting capabilities for trading signals
generated by LLM-based analysis.
"""

import json
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Callable
from datetime import datetime, timedelta
from enum import Enum
import asyncio

from .signal_generator import TradingSignal, SignalDirection


@dataclass
class BacktestConfig:
    """Configuration for backtesting."""
    initial_capital: float = 100000.0
    position_size_pct: float = 0.1  # 10% per trade
    max_positions: int = 5
    commission_pct: float = 0.001  # 0.1%
    slippage_pct: float = 0.0005  # 0.05%
    use_stop_loss: bool = True
    use_take_profit: bool = True
    allow_short: bool = True
    max_drawdown_pct: float = 0.2  # 20% max drawdown


@dataclass
class Trade:
    """Represents a single trade."""
    symbol: str
    direction: SignalDirection
    entry_price: float
    entry_time: datetime
    size: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    exit_price: Optional[float] = None
    exit_time: Optional[datetime] = None
    exit_reason: Optional[str] = None
    pnl: float = 0.0
    pnl_pct: float = 0.0
    llm_confidence: float = 0.0
    llm_reasoning: str = ""


@dataclass
class BacktestResult:
    """Results from backtesting."""
    total_return: float
    total_return_pct: float
    sharpe_ratio: float
    max_drawdown: float
    max_drawdown_pct: float
    win_rate: float
    profit_factor: float
    total_trades: int
    winning_trades: int
    losing_trades: int
    avg_win: float
    avg_loss: float
    avg_holding_period: float  # in hours
    trades: List[Trade] = field(default_factory=list)
    equity_curve: List[float] = field(default_factory=list)
    daily_returns: List[float] = field(default_factory=list)
    confidence_correlation: float = 0.0  # Correlation between LLM confidence and returns

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "total_return": self.total_return,
            "total_return_pct": self.total_return_pct,
            "sharpe_ratio": self.sharpe_ratio,
            "max_drawdown": self.max_drawdown,
            "max_drawdown_pct": self.max_drawdown_pct,
            "win_rate": self.win_rate,
            "profit_factor": self.profit_factor,
            "total_trades": self.total_trades,
            "winning_trades": self.winning_trades,
            "losing_trades": self.losing_trades,
            "avg_win": self.avg_win,
            "avg_loss": self.avg_loss,
            "avg_holding_period_hours": self.avg_holding_period,
            "confidence_correlation": self.confidence_correlation
        }


class LLMSignalBacktester:
    """
    Backtest trading signals generated by LLM analysis.

    Supports:
    - Multiple position management
    - Stop-loss and take-profit
    - Long and short positions
    - Commission and slippage modeling
    - Performance metrics calculation

    Example:
        >>> backtester = LLMSignalBacktester(config)
        >>> result = await backtester.run(signals, price_data)
        >>> print(f"Sharpe: {result.sharpe_ratio:.2f}")
    """

    def __init__(self, config: Optional[BacktestConfig] = None):
        """
        Initialize backtester.

        Args:
            config: Backtest configuration
        """
        self.config = config or BacktestConfig()
        self.capital = self.config.initial_capital
        self.positions: Dict[str, Trade] = {}
        self.closed_trades: List[Trade] = []
        self.equity_history: List[float] = []

    async def run(
        self,
        signals: List[TradingSignal],
        price_data: Dict[str, List[Dict[str, Any]]],
        verbose: bool = False
    ) -> BacktestResult:
        """
        Run backtest on signals.

        Args:
            signals: List of trading signals
            price_data: Dict mapping symbol to OHLCV data
            verbose: Print progress

        Returns:
            BacktestResult with metrics
        """
        self.capital = self.config.initial_capital
        self.positions = {}
        self.closed_trades = []
        self.equity_history = [self.capital]

        # Sort signals by timestamp
        sorted_signals = sorted(signals, key=lambda s: s.timestamp)

        for signal in sorted_signals:
            if signal.symbol not in price_data:
                continue

            # Get price at signal time
            prices = price_data[signal.symbol]
            current_price = self._get_price_at_time(prices, signal.timestamp)

            if current_price is None:
                continue

            # Update existing positions
            self._update_positions(price_data, signal.timestamp)

            # Process new signal
            if signal.direction != SignalDirection.FLAT:
                self._process_signal(signal, current_price)

            # Record equity
            equity = self._calculate_equity(price_data, signal.timestamp)
            self.equity_history.append(equity)

            # Check max drawdown
            if self._check_max_drawdown():
                if verbose:
                    print("Max drawdown reached, stopping backtest")
                break

        # Close all remaining positions
        self._close_all_positions(price_data)

        return self._calculate_results()

    def _process_signal(self, signal: TradingSignal, price: float):
        """Process a trading signal."""
        # Check if we already have position in this symbol
        if signal.symbol in self.positions:
            existing = self.positions[signal.symbol]

            # Close if opposite direction
            if existing.direction != signal.direction:
                self._close_position(signal.symbol, price, signal.timestamp, "signal_reversal")
            else:
                return  # Already have same direction position

        # Check max positions
        if len(self.positions) >= self.config.max_positions:
            return

        # Check if short allowed
        if signal.direction == SignalDirection.SHORT and not self.config.allow_short:
            return

        # Calculate position size
        position_value = self.capital * self.config.position_size_pct

        # Apply commission and slippage
        entry_price = price * (1 + self.config.slippage_pct)
        if signal.direction == SignalDirection.SHORT:
            entry_price = price * (1 - self.config.slippage_pct)

        size = position_value / entry_price
        commission = position_value * self.config.commission_pct

        # Create trade
        trade = Trade(
            symbol=signal.symbol,
            direction=signal.direction,
            entry_price=entry_price,
            entry_time=signal.timestamp,
            size=size,
            stop_loss=signal.stop_loss if self.config.use_stop_loss else None,
            take_profit=signal.take_profit[0] if self.config.use_take_profit and signal.take_profit else None,
            llm_confidence=signal.confidence,
            llm_reasoning=signal.reasoning
        )

        self.positions[signal.symbol] = trade
        self.capital -= commission

    def _update_positions(
        self,
        price_data: Dict[str, List[Dict[str, Any]]],
        current_time: datetime
    ):
        """Update positions and check stop/take profit."""
        symbols_to_close = []

        for symbol, trade in self.positions.items():
            if symbol not in price_data:
                continue

            current_price = self._get_price_at_time(price_data[symbol], current_time)
            if current_price is None:
                continue

            # Check stop loss
            if trade.stop_loss:
                if trade.direction == SignalDirection.LONG and current_price <= trade.stop_loss:
                    symbols_to_close.append((symbol, current_price, "stop_loss"))
                elif trade.direction == SignalDirection.SHORT and current_price >= trade.stop_loss:
                    symbols_to_close.append((symbol, current_price, "stop_loss"))

            # Check take profit
            if trade.take_profit:
                if trade.direction == SignalDirection.LONG and current_price >= trade.take_profit:
                    symbols_to_close.append((symbol, current_price, "take_profit"))
                elif trade.direction == SignalDirection.SHORT and current_price <= trade.take_profit:
                    symbols_to_close.append((symbol, current_price, "take_profit"))

        for symbol, price, reason in symbols_to_close:
            self._close_position(symbol, price, current_time, reason)

    def _close_position(
        self,
        symbol: str,
        price: float,
        time: datetime,
        reason: str
    ):
        """Close a position."""
        if symbol not in self.positions:
            return

        trade = self.positions[symbol]

        # Apply slippage
        exit_price = price * (1 - self.config.slippage_pct)
        if trade.direction == SignalDirection.SHORT:
            exit_price = price * (1 + self.config.slippage_pct)

        # Calculate P&L
        if trade.direction == SignalDirection.LONG:
            pnl = (exit_price - trade.entry_price) * trade.size
        else:
            pnl = (trade.entry_price - exit_price) * trade.size

        # Subtract commission
        commission = abs(trade.size * exit_price * self.config.commission_pct)
        pnl -= commission

        # Update trade
        trade.exit_price = exit_price
        trade.exit_time = time
        trade.exit_reason = reason
        trade.pnl = pnl
        trade.pnl_pct = pnl / (trade.entry_price * trade.size) * 100

        # Update capital
        self.capital += trade.entry_price * trade.size + pnl

        # Move to closed trades
        self.closed_trades.append(trade)
        del self.positions[symbol]

    def _close_all_positions(self, price_data: Dict[str, List[Dict[str, Any]]]):
        """Close all remaining positions at last price."""
        symbols = list(self.positions.keys())

        for symbol in symbols:
            if symbol in price_data and price_data[symbol]:
                last_price = price_data[symbol][-1].get("close", 0)
                last_time = price_data[symbol][-1].get(
                    "timestamp",
                    datetime.now()
                )
                if isinstance(last_time, str):
                    last_time = datetime.fromisoformat(last_time.replace("Z", "+00:00"))
                self._close_position(symbol, last_price, last_time, "end_of_backtest")

    def _get_price_at_time(
        self,
        prices: List[Dict[str, Any]],
        target_time: datetime
    ) -> Optional[float]:
        """Get price at or before target time."""
        if not prices:
            return None

        for i, bar in enumerate(prices):
            bar_time = bar.get("timestamp")
            if isinstance(bar_time, str):
                bar_time = datetime.fromisoformat(bar_time.replace("Z", "+00:00"))

            if bar_time and bar_time >= target_time:
                return bar.get("close")

        return prices[-1].get("close") if prices else None

    def _calculate_equity(
        self,
        price_data: Dict[str, List[Dict[str, Any]]],
        current_time: datetime
    ) -> float:
        """Calculate current equity."""
        equity = self.capital

        for symbol, trade in self.positions.items():
            if symbol in price_data:
                current_price = self._get_price_at_time(price_data[symbol], current_time)
                if current_price:
                    if trade.direction == SignalDirection.LONG:
                        unrealized = (current_price - trade.entry_price) * trade.size
                    else:
                        unrealized = (trade.entry_price - current_price) * trade.size
                    equity += trade.entry_price * trade.size + unrealized

        return equity

    def _check_max_drawdown(self) -> bool:
        """Check if max drawdown exceeded."""
        if not self.equity_history:
            return False

        peak = max(self.equity_history)
        current = self.equity_history[-1]
        drawdown_pct = (peak - current) / peak

        return drawdown_pct >= self.config.max_drawdown_pct

    def _calculate_results(self) -> BacktestResult:
        """Calculate backtest results."""
        if not self.closed_trades:
            return BacktestResult(
                total_return=0,
                total_return_pct=0,
                sharpe_ratio=0,
                max_drawdown=0,
                max_drawdown_pct=0,
                win_rate=0,
                profit_factor=0,
                total_trades=0,
                winning_trades=0,
                losing_trades=0,
                avg_win=0,
                avg_loss=0,
                avg_holding_period=0,
                trades=[],
                equity_curve=self.equity_history
            )

        # Basic metrics
        total_pnl = sum(t.pnl for t in self.closed_trades)
        total_return_pct = (total_pnl / self.config.initial_capital) * 100

        # Win/loss metrics
        winners = [t for t in self.closed_trades if t.pnl > 0]
        losers = [t for t in self.closed_trades if t.pnl <= 0]

        win_rate = len(winners) / len(self.closed_trades) if self.closed_trades else 0

        total_wins = sum(t.pnl for t in winners) if winners else 0
        total_losses = abs(sum(t.pnl for t in losers)) if losers else 0

        profit_factor = total_wins / total_losses if total_losses > 0 else float('inf')

        avg_win = total_wins / len(winners) if winners else 0
        avg_loss = total_losses / len(losers) if losers else 0

        # Drawdown
        peak = self.equity_history[0]
        max_dd = 0
        max_dd_pct = 0

        for equity in self.equity_history:
            if equity > peak:
                peak = equity
            dd = peak - equity
            dd_pct = dd / peak if peak > 0 else 0
            if dd > max_dd:
                max_dd = dd
                max_dd_pct = dd_pct

        # Daily returns for Sharpe
        daily_returns = []
        for i in range(1, len(self.equity_history)):
            ret = (self.equity_history[i] - self.equity_history[i-1]) / self.equity_history[i-1]
            daily_returns.append(ret)

        # Sharpe ratio (assuming 252 trading days)
        if daily_returns:
            import statistics
            avg_return = statistics.mean(daily_returns)
            std_return = statistics.stdev(daily_returns) if len(daily_returns) > 1 else 1
            sharpe = (avg_return * 252) / (std_return * (252 ** 0.5)) if std_return > 0 else 0
        else:
            sharpe = 0

        # Average holding period
        holding_periods = []
        for t in self.closed_trades:
            if t.exit_time and t.entry_time:
                delta = t.exit_time - t.entry_time
                holding_periods.append(delta.total_seconds() / 3600)  # hours

        avg_holding = sum(holding_periods) / len(holding_periods) if holding_periods else 0

        # Confidence correlation
        conf_corr = self._calculate_confidence_correlation()

        return BacktestResult(
            total_return=total_pnl,
            total_return_pct=total_return_pct,
            sharpe_ratio=sharpe,
            max_drawdown=max_dd,
            max_drawdown_pct=max_dd_pct * 100,
            win_rate=win_rate * 100,
            profit_factor=profit_factor,
            total_trades=len(self.closed_trades),
            winning_trades=len(winners),
            losing_trades=len(losers),
            avg_win=avg_win,
            avg_loss=avg_loss,
            avg_holding_period=avg_holding,
            trades=self.closed_trades,
            equity_curve=self.equity_history,
            daily_returns=daily_returns,
            confidence_correlation=conf_corr
        )

    def _calculate_confidence_correlation(self) -> float:
        """Calculate correlation between LLM confidence and trade returns."""
        if len(self.closed_trades) < 3:
            return 0.0

        confidences = [t.llm_confidence for t in self.closed_trades]
        returns = [t.pnl_pct for t in self.closed_trades]

        # Simple correlation
        n = len(confidences)
        mean_conf = sum(confidences) / n
        mean_ret = sum(returns) / n

        num = sum((c - mean_conf) * (r - mean_ret) for c, r in zip(confidences, returns))

        var_conf = sum((c - mean_conf) ** 2 for c in confidences)
        var_ret = sum((r - mean_ret) ** 2 for r in returns)

        denom = (var_conf * var_ret) ** 0.5

        return num / denom if denom > 0 else 0


# Walk-forward optimization
class WalkForwardOptimizer:
    """
    Walk-forward optimization for LLM trading strategies.

    Tests strategy robustness by training on in-sample data
    and validating on out-of-sample data.
    """

    def __init__(
        self,
        in_sample_pct: float = 0.7,
        num_folds: int = 5
    ):
        """
        Initialize optimizer.

        Args:
            in_sample_pct: Percentage for in-sample
            num_folds: Number of walk-forward folds
        """
        self.in_sample_pct = in_sample_pct
        self.num_folds = num_folds

    async def optimize(
        self,
        signal_generator,
        price_data: Dict[str, List[Dict[str, Any]]],
        news_data: List[Dict[str, Any]],
        config: BacktestConfig
    ) -> Dict[str, Any]:
        """
        Run walk-forward optimization.

        Args:
            signal_generator: Signal generator instance
            price_data: Historical price data
            news_data: Historical news data
            config: Backtest configuration

        Returns:
            Optimization results
        """
        results = []

        # Split data into folds
        total_news = len(news_data)
        fold_size = total_news // self.num_folds

        for fold in range(self.num_folds):
            # Define in-sample and out-of-sample periods
            start_idx = fold * fold_size
            end_idx = (fold + 1) * fold_size

            in_sample_end = start_idx + int(fold_size * self.in_sample_pct)

            in_sample_news = news_data[start_idx:in_sample_end]
            out_sample_news = news_data[in_sample_end:end_idx]

            # Generate signals for both periods
            in_signals = []
            out_signals = []

            for news in in_sample_news:
                signal = await signal_generator.generate_news_signal(
                    news.get("headline", ""),
                    news.get("symbol", ""),
                    news.get("current_price", 100)
                )
                in_signals.append(signal)

            for news in out_sample_news:
                signal = await signal_generator.generate_news_signal(
                    news.get("headline", ""),
                    news.get("symbol", ""),
                    news.get("current_price", 100)
                )
                out_signals.append(signal)

            # Backtest out-of-sample
            backtester = LLMSignalBacktester(config)
            result = await backtester.run(out_signals, price_data)

            results.append({
                "fold": fold,
                "in_sample_signals": len(in_signals),
                "out_sample_signals": len(out_signals),
                "sharpe": result.sharpe_ratio,
                "return_pct": result.total_return_pct,
                "win_rate": result.win_rate,
                "trades": result.total_trades
            })

        # Aggregate results
        avg_sharpe = sum(r["sharpe"] for r in results) / len(results) if results else 0
        avg_return = sum(r["return_pct"] for r in results) / len(results) if results else 0
        avg_win_rate = sum(r["win_rate"] for r in results) / len(results) if results else 0

        return {
            "fold_results": results,
            "avg_sharpe": avg_sharpe,
            "avg_return_pct": avg_return,
            "avg_win_rate": avg_win_rate,
            "robustness_score": avg_sharpe * (avg_win_rate / 100) if avg_win_rate > 0 else 0
        }


# Example usage
async def main():
    """Demo of backtesting."""
    from datetime import datetime, timedelta
    from .signal_generator import PromptBasedSignalGenerator, TradingSignal, SignalDirection, SignalStrength
    from .llm_client import MockLLMClient

    # Create mock signals
    base_time = datetime(2024, 1, 1, 9, 30)
    signals = [
        TradingSignal(
            symbol="AAPL",
            direction=SignalDirection.LONG,
            strength=SignalStrength.STRONG,
            confidence=80,
            entry_price=185.0,
            entry_type="MARKET",
            stop_loss=180.0,
            take_profit=[195.0],
            position_size_pct=0.1,
            reasoning="Strong earnings report",
            timestamp=base_time
        ),
        TradingSignal(
            symbol="AAPL",
            direction=SignalDirection.SHORT,
            strength=SignalStrength.MODERATE,
            confidence=75,
            entry_price=192.0,
            entry_type="MARKET",
            stop_loss=197.0,
            take_profit=[182.0],
            position_size_pct=0.1,
            reasoning="Technical resistance reached",
            timestamp=base_time + timedelta(days=5)
        ),
        TradingSignal(
            symbol="MSFT",
            direction=SignalDirection.LONG,
            strength=SignalStrength.STRONG,
            confidence=85,
            entry_price=380.0,
            entry_type="MARKET",
            stop_loss=370.0,
            take_profit=[400.0],
            position_size_pct=0.1,
            reasoning="AI momentum play",
            timestamp=base_time + timedelta(days=2)
        )
    ]

    # Create mock price data
    price_data = {
        "AAPL": [
            {"timestamp": base_time + timedelta(days=i), "close": 185 + i * 1.5}
            for i in range(10)
        ],
        "MSFT": [
            {"timestamp": base_time + timedelta(days=i), "close": 380 + i * 2}
            for i in range(10)
        ]
    }

    # Run backtest
    config = BacktestConfig(
        initial_capital=100000,
        position_size_pct=0.1,
        max_positions=3
    )

    backtester = LLMSignalBacktester(config)
    result = await backtester.run(signals, price_data, verbose=True)

    print("Backtest Results")
    print("=" * 50)
    print(f"Total Return: ${result.total_return:,.2f} ({result.total_return_pct:.2f}%)")
    print(f"Sharpe Ratio: {result.sharpe_ratio:.2f}")
    print(f"Max Drawdown: {result.max_drawdown_pct:.2f}%")
    print(f"Win Rate: {result.win_rate:.1f}%")
    print(f"Profit Factor: {result.profit_factor:.2f}")
    print(f"Total Trades: {result.total_trades}")
    print(f"Avg Holding Period: {result.avg_holding_period:.1f} hours")
    print(f"Confidence Correlation: {result.confidence_correlation:.3f}")

    print("\nTrade Details:")
    for trade in result.trades:
        print(f"  {trade.symbol}: {trade.direction.value} @ {trade.entry_price:.2f}")
        print(f"    Exit: {trade.exit_price:.2f} ({trade.exit_reason})")
        print(f"    P&L: ${trade.pnl:.2f} ({trade.pnl_pct:.2f}%)")


if __name__ == "__main__":
    asyncio.run(main())

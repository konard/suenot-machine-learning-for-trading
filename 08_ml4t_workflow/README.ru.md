# Рабочий процесс ML4T: от модели машинного обучения к бэктестированию стратегии

Эта глава объединяет различные строительные блоки рабочего процесса машинного обучения для трейдинга (ML4T) и представляет сквозной взгляд на процесс проектирования, симуляции и оценки торговой стратегии, основанной на машинном обучении. Самое важное — здесь подробно демонстрируется, как подготовить, спроектировать, запустить и оценить бэктест с использованием Python-библиотек backtrader и Zipline.

Конечная цель рабочего процесса ML4T — собрать доказательства на основе исторических данных, которые помогут принять решение о развёртывании стратегии-кандидата на реальном рынке и вложении финансовых ресурсов. Этот процесс основывается на навыках, которые вы развили в предыдущих главах, поскольку он опирается на вашу способность:

- работать с разнообразными источниками данных для создания информативных факторов,
- проектировать модели МО, генерирующие прогностические сигналы для вашей торговой стратегии, и
- оптимизировать результирующий портфель с точки зрения соотношения риска и доходности.

Реалистичная симуляция вашей стратегии также должна достоверно отражать работу рынков ценных бумаг и исполнение сделок. Поэтому институциональные детали бирж, такие как доступные типы ордеров и механизмы определения цен (см. [Главу 2, Рыночные и фундаментальные данные](../02_market_and_fundamental_data)), также важны при проектировании бэктеста или оценке того, включает ли движок бэктестирования необходимые функции для точного измерения производительности. Наконец, есть несколько методологических аспектов, требующих внимания, чтобы избежать смещённых результатов и ложных открытий, которые приведут к плохим инвестиционным решениям.

Данные, используемые для некоторых симуляций бэктеста, генерируются скриптом [data_prep.py](00_data/data_prep.py) в директории [data](00_data) и основаны на прогнозах доходности линейной регрессии из [Главы 7, Линейные модели](../07_linear_models).

## Содержание

1. [Как бэктестировать стратегию на основе МО](#как-бэктестировать-стратегию-на-основе-мо)
2. [Подводные камни бэктестирования и как их избежать](#подводные-камни-бэктестирования-и-как-их-избежать)
    * [Правильная работа с данными](#правильная-работа-с-данными)
    * [Правильная симуляция](#правильная-симуляция)
    * [Правильная статистика: подглядывание в данные и переобучение бэктеста](#правильная-статистика-подглядывание-в-данные-и-переобучение-бэктеста)
    * [Пример кода: дефлированный коэффициент Шарпа](#пример-кода-дефлированный-коэффициент-шарпа)
    * [Литература](#литература)
3. [Как работает движок бэктестирования](#как-работает-движок-бэктестирования)
    * [Векторизованное vs событийно-управляемое бэктестирование](#векторизованное-vs-событийно-управляемое-бэктестирование)
    * [Пример кода: простой векторизованный бэктест](#пример-кода-простой-векторизованный-бэктест)
    * [Ключевые аспекты реализации](#ключевые-аспекты-реализации)
4. [backtrader: гибкий инструмент для локального бэктестирования](#backtrader-гибкий-инструмент-для-локального-бэктестирования)
    * [Ключевые концепции архитектуры Cerebro в backtrader](#ключевые-концепции-архитектуры-cerebro-в-backtrader)
    * [Пример кода: как использовать backtrader на практике](#пример-кода-как-использовать-backtrader-на-практике)
    * [Ресурсы](#ресурсы)
5. [zipline: готовое к продакшену бэктестирование от Quantopian](#zipline-готовое-к-продакшену-бэктестирование-от-quantopian)
    * [Примеры кода: загрузка данных и обучение моделей МО, локально и на Quantopian](#примеры-кода-загрузка-данных-и-обучение-моделей-мо-локально-и-на-quantopian)

## Как бэктестировать стратегию на основе МО

Если кратко, рабочий процесс ML4T — это бэктестирование торговой стратегии, которая использует машинное обучение для генерации торговых сигналов, выбора и определения размера позиций или оптимизации исполнения сделок. Он включает следующие шаги с учётом конкретного инвестиционного универсума и горизонта:

- Получение и подготовка рыночных, фундаментальных и альтернативных данных
- Создание прогностических альфа-факторов и признаков
- Проектирование, настройка и оценка моделей МО для генерации торговых сигналов
- Принятие решений о сделках на основе этих сигналов, например, с применением правил
- Определение размера отдельных позиций в контексте портфеля
- Симуляция результирующих сделок с использованием исторических рыночных данных
- Оценка того, как результирующие позиции показали бы себя

<p align="center">
<img src="https://i.imgur.com/kcgItgp.png" width="75%">
</p>

## Подводные камни бэктестирования и как их избежать

Бэктестирование симулирует алгоритмическую стратегию на основе исторических данных с целью получения результатов производительности, которые обобщаются на новые рыночные условия. Помимо общей неопределённости прогнозов в контексте постоянно меняющихся рынков, несколько аспектов реализации могут исказить результаты и повысить риск принятия in-sample производительности за паттерны, которые сохранятся out-of-sample.

### Правильная работа с данными

Проблемы с данными, которые подрывают валидность бэктеста, включают:
- смещение заглядывания вперёд (look-ahead bias),
- ошибку выжившего (survivorship bias),
- контроль выбросов, а также
- выбор периода выборки.

### Правильная симуляция

Практические проблемы, связанные с реализацией исторической симуляции, включают:
- неспособность производить переоценку по рынку для точного отражения рыночных цен и учёта просадок;
- нереалистичные предположения о доступности, стоимости или влиянии сделок на рынок;
- неправильный тайминг сигналов и исполнения сделок.

### Правильная статистика: подглядывание в данные и переобучение бэктеста

Наиболее серьёзный вызов валидности бэктеста, включая опубликованные результаты, связан с обнаружением ложных паттернов вследствие множественного тестирования в процессе выбора стратегии. Выбор стратегии после тестирования различных кандидатов на одних и тех же данных, вероятно, приведёт к смещению выбора, поскольку положительный результат скорее объясняется стохастической природой самой меры производительности. Другими словами, стратегия чрезмерно подогнана, или переобучена, под имеющиеся данные и даёт обманчиво положительные результаты.

[Маркос Лопес де Прадо](http://www.quantresearch.info/) много публиковался о рисках бэктестирования и о том, как их обнаружить или избежать. Это включает [онлайн-симулятор переобучения бэктеста](http://datagrid.lbl.gov/backtest/).

### Пример кода: дефлированный коэффициент Шарпа

Лопес де Прадо и Дэвид Бейли вывели дефлированный коэффициент Шарпа для вычисления вероятности того, что SR статистически значим, контролируя при этом инфляционный эффект множественного тестирования, ненормальных доходностей и более коротких периодов выборки.

Python-скрипт [deflated_sharpe_ratio](01_multiple_testing/deflated_sharpe_ratio.py) в директории [multiple_testing](01_multiple_testing) содержит реализацию на Python со ссылками на вывод соответствующих формул.

### Литература

- [The Deflated Sharpe Ratio: Correcting for Selection Bias, Backtest Overfitting and Non-Normality](https://www.davidhbailey.com/dhbpapers/deflated-sharpe.pdf), Bailey, David and Lopez de Prado, Marcos, Journal of Portfolio Management, 2013
- [Backtest Overfitting: An Interactive Example](http://datagrid.lbl.gov/backtest/)
- [Backtesting](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2606462), Lopez de Prado, Marcos, 2015
- [Secretary Problem (Optimal Stopping)](https://www.geeksforgeeks.org/secretary-problem-optimal-stopping-problem/)
- [Optimal Stopping and Applications](https://www.math.ucla.edu/~tom/Stopping/Contents.html), Ferguson, Math Department, UCLA
- [Advances in Machine Learning Lectures 4/10 - Backtesting I](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3257420), Marcos Lopez de Prado, 2018
- [Advances in Machine Learning Lectures 5/10 - Backtesting II](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3257497), Marcos Lopez de Prado, 2018

## Как работает движок бэктестирования

Проще говоря, движок бэктестирования перебирает исторические цены (и другие данные), передаёт текущие значения вашему алгоритму, получает ордера в ответ и отслеживает результирующие позиции и их стоимость. На практике существует множество требований для создания реалистичной и надёжной симуляции рабочего процесса ML4T, показанного выше. Разница между векторизованным и событийно-управляемым подходами иллюстрирует, как точное воспроизведение реальной торговой среды значительно усложняет систему.

### Векторизованное vs событийно-управляемое бэктестирование

Векторизованный бэктест — это самый простой способ оценки стратегии. Он просто умножает вектор сигнала, представляющий целевой размер позиции, на вектор доходностей для инвестиционного горизонта, чтобы вычислить производительность за период.

### Пример кода: простой векторизованный бэктест

Мы иллюстрируем векторизованный подход, используя ежедневные прогнозы доходности, которые мы создали с помощью гребневой регрессии в [Главе 7](../07_linear_models).

- Примеры кода для этого раздела находятся в ноутбуке [vectorized_backtest](02_vectorized_backtest.ipynb).

### Ключевые аспекты реализации

Требования для реалистичной симуляции могут быть удовлетворены единой платформой, поддерживающей все этапы процесса сквозным образом, или несколькими инструментами, каждый из которых специализируется на различных аспектах. Например, вы можете обрабатывать проектирование и тестирование моделей МО, генерирующих сигналы, с помощью общих библиотек МО, таких как scikit-learn или других, которые мы встретим в этой книге, и передавать выходы модели в отдельный движок бэктестирования. Альтернативно, вы можете запускать весь рабочий процесс ML4T сквозным образом на единой платформе, такой как Quantopian и QuantConnect.

Следующие детали реализации должны быть учтены для запуска этого процесса и подробнее обсуждаются в этом разделе книги:
- Загрузка данных: формат, частота и тайминг
- Создание факторов: встроенные вычисления vs сторонние библиотеки
- Модели МО, прогнозы и сигналы
- Торговые правила и исполнение
- Оценка производительности

## backtrader: гибкий инструмент для локального бэктестирования

backtrader — это популярная, гибкая и удобная Python-библиотека для локального бэктестирования с отличной документацией, разрабатываемая с 2015 года Даниэлем Родригесом. Помимо большого и активного сообщества индивидуальных трейдеров, несколько банков и торговых домов используют backtrader для прототипирования и тестирования новых стратегий перед их переносом на production-ready платформу с использованием, например, Java. Вы также можете использовать backtrader для live-трейдинга с несколькими брокерами на ваш выбор (см. [документацию](https://www.backtrader.com/docu/) backtrader и [Главу 23, Следующие шаги](../23_next_steps)).

- Примеры кода для этого раздела находятся в ноутбуке [backtesting_with_backtrader](03_backtesting_with_backtrader.ipynb).

### Ключевые концепции архитектуры Cerebro в backtrader

Архитектура Cerebro (с испанского — «мозг») в backtrader представляет ключевые компоненты рабочего процесса бэктестирования как (расширяемые) Python-объекты. Эти объекты взаимодействуют для обработки входных данных и вычисления факторов, формулирования и исполнения стратегии, получения и исполнения ордеров, а также отслеживания и измерения производительности. Экземпляр Cerebro оркестрирует весь процесс от сбора входных данных до исполнения бэктеста бар за баром и предоставления результатов.

Библиотека использует соглашения для этих взаимодействий, которые позволяют опустить некоторые детали и упростить настройку бэктестирования. Я настоятельно рекомендую просмотреть [документацию](https://www.backtrader.com/docu/), чтобы углубиться, если вы планируете использовать backtrader для разработки собственных стратегий.

<p align="center">
<img src="https://i.imgur.com/MTp7UaQ.png" width="75%">
</p>

### Пример кода: как использовать backtrader на практике

Мы продемонстрируем backtrader, снова используя ежедневные прогнозы доходности от гребневой регрессии из Главы 7, Линейные модели, как и для векторизованного бэктеста ранее в этой главе. Мы создадим экземпляр Cerebro, загрузим данные, сформулируем и добавим стратегию, запустим бэктест и рассмотрим результаты.

Ноутбук [backtesting_with_backtrader](03_backtesting_with_backtrader.ipynb) содержит примеры кода и некоторые дополнительные детали.

### Ресурсы

- Сайт [Backtrader](https://www.backtrader.com/)
    - [Документация](https://www.backtrader.com/docu/)
    - [Установка](https://www.backtrader.com/docu/installation/)

## zipline: готовое к продакшену бэктестирование от Quantopian

Открытая библиотека [Zipline](https://zipline.ml4trading.io/index.html) — это событийно-управляемая система бэктестирования, поддерживаемая и используемая в продакшене краудсорсинговым количественным инвестиционным фондом [Quantopian](https://www.quantopian.com/) для разработки алгоритмов и live-трейдинга. Она автоматизирует реакцию алгоритма на торговые события и предоставляет ему текущие и исторические данные point-in-time, что позволяет избежать смещения заглядывания вперёд.

В [Главе 4](../04_alpha_factor_research) мы представили `zipline` для симуляции вычисления альфа-факторов, а в [Главе 5](../05_strategy_evaluation) мы добавили сделки для симуляции простой стратегии и измерения её производительности, а также оптимизации портфельных позиций с использованием различных техник.

### Примеры кода: загрузка данных и обучение моделей МО, локально и на Quantopian

Код для этого раздела находится в поддиректории [ml4t_workflow_with_zipline](04_ml4t_workflow_with_zipline). Подробности см. в [README](04_ml4t_workflow_with_zipline/README.md).

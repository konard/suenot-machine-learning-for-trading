//! Base strategy trait and signal types.

use crate::models::Candle;

/// Trading signal generated by a strategy.
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Signal {
    /// Buy signal with strength (0.0 to 1.0)
    Buy(f64),
    /// Sell signal with strength (0.0 to 1.0)
    Sell(f64),
    /// Close all positions
    Close,
    /// Hold current position (no action)
    Hold,
}

impl Signal {
    /// Create a full strength buy signal.
    pub fn buy() -> Self {
        Signal::Buy(1.0)
    }

    /// Create a full strength sell signal.
    pub fn sell() -> Self {
        Signal::Sell(1.0)
    }

    /// Check if this is a buy signal.
    pub fn is_buy(&self) -> bool {
        matches!(self, Signal::Buy(_))
    }

    /// Check if this is a sell signal.
    pub fn is_sell(&self) -> bool {
        matches!(self, Signal::Sell(_))
    }

    /// Get the signal strength (0.0 for Hold/Close).
    pub fn strength(&self) -> f64 {
        match self {
            Signal::Buy(s) | Signal::Sell(s) => *s,
            _ => 0.0,
        }
    }

    /// Convert signal to position target (-1.0 to 1.0).
    pub fn to_position(&self) -> f64 {
        match self {
            Signal::Buy(s) => *s,
            Signal::Sell(s) => -*s,
            Signal::Close | Signal::Hold => 0.0,
        }
    }
}

/// Trait for implementing trading strategies.
pub trait Strategy {
    /// Get the strategy name.
    fn name(&self) -> &str;

    /// Process a new candle and generate a trading signal.
    ///
    /// # Arguments
    /// * `candle` - The current candle
    /// * `historical` - All historical candles up to and including current
    ///
    /// # Returns
    /// A trading signal indicating the desired action.
    fn on_candle(&mut self, candle: &Candle, historical: &[Candle]) -> Signal;

    /// Reset the strategy state.
    fn reset(&mut self) {}

    /// Get minimum required history length.
    fn min_history(&self) -> usize {
        1
    }
}

/// Wrapper for combining multiple strategies.
pub struct StrategyEnsemble {
    strategies: Vec<Box<dyn Strategy>>,
    weights: Vec<f64>,
}

impl StrategyEnsemble {
    /// Create a new ensemble with equal weights.
    pub fn new(strategies: Vec<Box<dyn Strategy>>) -> Self {
        let n = strategies.len();
        let weights = vec![1.0 / n as f64; n];
        Self { strategies, weights }
    }

    /// Create a new ensemble with custom weights.
    pub fn with_weights(strategies: Vec<Box<dyn Strategy>>, weights: Vec<f64>) -> Self {
        assert_eq!(strategies.len(), weights.len());
        Self { strategies, weights }
    }
}

impl Strategy for StrategyEnsemble {
    fn name(&self) -> &str {
        "Ensemble"
    }

    fn on_candle(&mut self, candle: &Candle, historical: &[Candle]) -> Signal {
        let mut total_position = 0.0;

        for (strategy, weight) in self.strategies.iter_mut().zip(self.weights.iter()) {
            let signal = strategy.on_candle(candle, historical);
            total_position += signal.to_position() * weight;
        }

        // Convert weighted position back to signal
        if total_position > 0.1 {
            Signal::Buy(total_position.min(1.0))
        } else if total_position < -0.1 {
            Signal::Sell((-total_position).min(1.0))
        } else {
            Signal::Hold
        }
    }

    fn reset(&mut self) {
        for strategy in &mut self.strategies {
            strategy.reset();
        }
    }

    fn min_history(&self) -> usize {
        self.strategies
            .iter()
            .map(|s| s.min_history())
            .max()
            .unwrap_or(1)
    }
}

"""
Real-Time Prediction for Trading

This module provides real-time prediction capabilities with KV-cache
optimization for low-latency trading signals.
"""

import torch
import numpy as np
from typing import Dict, List, Optional
import time
import asyncio
from dataclasses import dataclass

from .model import KVCacheTrader, KVCacheConfig
from .inference import OptimizedInferenceEngine, StreamingInferenceEngine
from .data_loader import create_streaming_generator


@dataclass
class TradingSignal:
    """Trading signal generated by the model."""
    timestamp: float
    symbol: str
    direction: str  # 'LONG', 'SHORT', 'NEUTRAL'
    confidence: float
    predicted_return: float
    latency_ms: float


class RealTimePredictor:
    """
    Real-time predictor for algorithmic trading.

    Features:
    - Low-latency predictions with KV-cache
    - Signal generation with confidence levels
    - Multi-asset support
    """

    def __init__(
        self,
        model_path: Optional[str] = None,
        config: Optional[KVCacheConfig] = None,
        symbols: List[str] = None,
        device: str = 'cuda'
    ):
        config = config or KVCacheConfig()
        symbols = symbols or ['BTCUSDT']

        # Use CPU if CUDA not available
        if device == 'cuda' and not torch.cuda.is_available():
            device = 'cpu'

        # Create or load model
        self.model = KVCacheTrader(
            input_dim=5,  # Standard feature set
            d_model=256,
            n_heads=8,
            n_layers=6,
            cache_config=config
        )

        if model_path is not None:
            self.model.load_state_dict(torch.load(model_path, map_location=device))

        self.model.to(device)
        self.model.eval()

        self.symbols = symbols
        self.device = device

        # Per-symbol streaming engines
        self.engines = {
            symbol: StreamingInferenceEngine(self.model, device=device)
            for symbol in symbols
        }

        # Signal thresholds
        self.long_threshold = 0.001  # 0.1% expected return
        self.short_threshold = -0.001
        self.confidence_threshold = 0.6

    def process_market_update(
        self,
        symbol: str,
        market_data: Dict
    ) -> Optional[TradingSignal]:
        """
        Process a market update and generate trading signal.

        Args:
            symbol: Trading symbol
            market_data: Market data dictionary

        Returns:
            TradingSignal if conditions met, else None
        """
        if symbol not in self.engines:
            raise ValueError(f"Unknown symbol: {symbol}")

        # Extract features
        features = np.array([
            market_data.get('log_return', 0),
            market_data.get('volatility', 0.01),
            market_data.get('volume_ratio', 1),
            market_data.get('momentum', 0),
            market_data.get('rsi', 50) / 100
        ], dtype=np.float32)

        # Get prediction
        result = self.engines[symbol].process_tick(features)

        prediction = result['prediction'][0]
        confidence = min(abs(prediction) * 100, 1.0)  # Normalize confidence

        # Generate signal
        if prediction > self.long_threshold and confidence > self.confidence_threshold:
            direction = 'LONG'
        elif prediction < self.short_threshold and confidence > self.confidence_threshold:
            direction = 'SHORT'
        else:
            direction = 'NEUTRAL'

        return TradingSignal(
            timestamp=time.time(),
            symbol=symbol,
            direction=direction,
            confidence=confidence,
            predicted_return=prediction,
            latency_ms=result['latency_ms']
        )

    def reset_symbol(self, symbol: str):
        """Reset the streaming engine for a symbol."""
        if symbol in self.engines:
            self.engines[symbol].reset()

    def reset_all(self):
        """Reset all streaming engines."""
        for engine in self.engines.values():
            engine.reset()

    async def run_async(
        self,
        data_streams: Dict[str, asyncio.Queue],
        signal_callback
    ):
        """
        Run asynchronous prediction loop.

        Args:
            data_streams: Queues for each symbol's data
            signal_callback: Async function called with each signal
        """
        async def process_symbol(symbol: str, queue: asyncio.Queue):
            while True:
                market_data = await queue.get()
                signal = self.process_market_update(symbol, market_data)
                if signal and signal.direction != 'NEUTRAL':
                    await signal_callback(signal)

        tasks = [
            process_symbol(symbol, queue)
            for symbol, queue in data_streams.items()
        ]

        await asyncio.gather(*tasks)


def run_demo(symbols: List[str] = None, num_ticks: int = 100):
    """Run a demonstration of the real-time predictor."""
    symbols = symbols or ['BTCUSDT', 'ETHUSDT']

    # Configuration
    config = KVCacheConfig(
        cache_type='standard',
        max_cache_size=2048
    )

    # Create predictor
    predictor = RealTimePredictor(
        model_path=None,  # Use random weights for demo
        config=config,
        symbols=symbols,
        device='cpu'
    )

    print(f"Running real-time prediction demo for {symbols}")
    print(f"Processing {num_ticks} ticks per symbol\n")

    # Simulate streaming data
    for symbol in symbols:
        print(f"\n{symbol} Predictions:")

        try:
            stream = create_streaming_generator(symbol, lookback_days=7)

            signal_count = 0
            for i, market_data in enumerate(stream):
                if i >= num_ticks:
                    break

                signal = predictor.process_market_update(symbol, market_data)

                if signal.direction != 'NEUTRAL':
                    signal_count += 1
                    print(f"  [{i+1}] {signal.direction}: conf={signal.confidence:.2f}, "
                          f"pred_ret={signal.predicted_return:.4f}, "
                          f"latency={signal.latency_ms:.2f}ms")

            print(f"  Total signals: {signal_count}/{num_ticks}")

        except Exception as e:
            print(f"  Error fetching data for {symbol}: {e}")
            print("  Using synthetic data instead...")

            # Fall back to synthetic data
            for i in range(num_ticks):
                market_data = {
                    'log_return': np.random.randn() * 0.01,
                    'volatility': abs(np.random.randn() * 0.02),
                    'volume_ratio': 1 + np.random.randn() * 0.3,
                    'momentum': np.random.randn() * 0.05,
                    'rsi': 50 + np.random.randn() * 20
                }

                signal = predictor.process_market_update(symbol, market_data)

                if signal.direction != 'NEUTRAL':
                    print(f"  [{i+1}] {signal.direction}: conf={signal.confidence:.2f}, "
                          f"pred_ret={signal.predicted_return:.4f}, "
                          f"latency={signal.latency_ms:.2f}ms")


def main():
    """Main entry point."""
    run_demo()


if __name__ == '__main__':
    main()

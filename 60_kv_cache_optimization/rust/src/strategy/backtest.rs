//! Backtesting framework for KV-cache trading strategies.

use crate::model::KVCacheTrader;
use crate::data::MarketData;
use crate::StreamingEngine;

/// Trading signal generated by the model.
#[derive(Debug, Clone)]
pub struct TradingSignal {
    /// Timestamp
    pub timestamp: i64,
    /// Trading symbol
    pub symbol: String,
    /// Direction: "LONG", "SHORT", or "NEUTRAL"
    pub direction: String,
    /// Confidence level (0-1)
    pub confidence: f64,
    /// Predicted return
    pub predicted_return: f64,
    /// Inference latency in milliseconds
    pub latency_ms: f64,
}

/// Backtest results.
#[derive(Debug, Clone)]
pub struct BacktestResult {
    /// Total return
    pub total_return: f64,
    /// Sharpe ratio (annualized)
    pub sharpe_ratio: f64,
    /// Sortino ratio (annualized)
    pub sortino_ratio: f64,
    /// Maximum drawdown
    pub max_drawdown: f64,
    /// Win rate
    pub win_rate: f64,
    /// Average inference latency
    pub avg_latency_ms: f64,
    /// Total number of trades
    pub total_trades: usize,
    /// Portfolio value history
    pub portfolio_values: Vec<f64>,
}

/// Backtester for KV-cache trading strategies.
pub struct Backtester {
    engine: StreamingEngine,
    initial_capital: f64,
    transaction_cost: f64,
    position_size: f64,
    long_threshold: f64,
    short_threshold: f64,
}

impl Backtester {
    /// Create a new backtester.
    pub fn new(
        model: KVCacheTrader,
        initial_capital: f64,
        transaction_cost: f64,
        position_size: f64,
    ) -> Self {
        Self {
            engine: StreamingEngine::new(model, 4096),
            initial_capital,
            transaction_cost,
            position_size,
            long_threshold: 0.001,
            short_threshold: -0.001,
        }
    }

    /// Run backtest on market data.
    pub fn run(&mut self, data: &[MarketData]) -> anyhow::Result<BacktestResult> {
        self.engine.reset();

        let mut capital = self.initial_capital;
        let mut portfolio_values = vec![capital];
        let mut position = 0.0;
        let mut trades = 0;
        let mut latencies = Vec::new();
        let mut wins = 0;
        let mut total_trades_for_win_rate = 0;

        for i in 0..data.len() - 1 {
            let features = data[i].to_features();

            // Get prediction
            let result = self.engine.process_tick(&features)?;
            latencies.push(result.latency_ms);

            let prediction = result.value as f64;

            // Generate signal
            let signal = (prediction * 10.0).tanh();
            let target_position = signal * self.position_size;

            // Calculate position change
            let position_change = target_position - position;
            let trade_cost = position_change.abs() * self.transaction_cost * capital;

            if position_change.abs() > 0.01 {
                trades += 1;
            }

            position = target_position;

            // Calculate actual return
            let actual_return = data[i + 1].log_return;
            let step_return = position * actual_return;

            // Track wins
            if position_change.abs() > 0.01 {
                total_trades_for_win_rate += 1;
                if (position > 0.0 && actual_return > 0.0) || (position < 0.0 && actual_return < 0.0) {
                    wins += 1;
                }
            }

            capital = capital * (1.0 + step_return) - trade_cost;
            portfolio_values.push(capital);
        }

        // Calculate metrics
        let returns: Vec<f64> = portfolio_values.windows(2)
            .map(|w| (w[1] - w[0]) / w[0])
            .collect();

        let metrics = calculate_metrics(&returns);

        Ok(BacktestResult {
            total_return: metrics.total_return,
            sharpe_ratio: metrics.sharpe_ratio,
            sortino_ratio: metrics.sortino_ratio,
            max_drawdown: metrics.max_drawdown,
            win_rate: if total_trades_for_win_rate > 0 {
                wins as f64 / total_trades_for_win_rate as f64
            } else {
                0.0
            },
            avg_latency_ms: if latencies.is_empty() {
                0.0
            } else {
                latencies.iter().sum::<f64>() / latencies.len() as f64
            },
            total_trades: trades,
            portfolio_values,
        })
    }
}

/// Internal metrics calculation.
struct Metrics {
    total_return: f64,
    sharpe_ratio: f64,
    sortino_ratio: f64,
    max_drawdown: f64,
}

fn calculate_metrics(returns: &[f64]) -> Metrics {
    if returns.is_empty() {
        return Metrics {
            total_return: 0.0,
            sharpe_ratio: 0.0,
            sortino_ratio: 0.0,
            max_drawdown: 0.0,
        };
    }

    // Total return
    let total_return: f64 = returns.iter().fold(1.0, |acc, r| acc * (1.0 + r)) - 1.0;

    // Mean return
    let mean_return: f64 = returns.iter().sum::<f64>() / returns.len() as f64;

    // Standard deviation
    let variance: f64 = returns.iter()
        .map(|r| (r - mean_return).powi(2))
        .sum::<f64>() / returns.len() as f64;
    let std_dev = variance.sqrt();

    // Sharpe ratio (annualized)
    let sharpe_ratio = if std_dev > 1e-8 {
        (252.0_f64).sqrt() * mean_return / std_dev
    } else {
        0.0
    };

    // Downside deviation for Sortino
    let downside_returns: Vec<f64> = returns.iter()
        .filter(|&&r| r < 0.0)
        .copied()
        .collect();
    let downside_std = if !downside_returns.is_empty() {
        let sum_sq: f64 = downside_returns.iter().map(|r| r.powi(2)).sum();
        (sum_sq / downside_returns.len() as f64).sqrt()
    } else {
        1e-8
    };

    let sortino_ratio = (252.0_f64).sqrt() * mean_return / downside_std;

    // Maximum drawdown
    let mut peak = 1.0;
    let mut max_drawdown = 0.0;
    let mut cumulative = 1.0;

    for r in returns {
        cumulative *= 1.0 + r;
        if cumulative > peak {
            peak = cumulative;
        }
        let drawdown = (peak - cumulative) / peak;
        if drawdown > max_drawdown {
            max_drawdown = drawdown;
        }
    }

    Metrics {
        total_return,
        sharpe_ratio,
        sortino_ratio,
        max_drawdown: -max_drawdown,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_metrics_calculation() {
        let returns = vec![0.01, -0.005, 0.02, -0.01, 0.015];
        let metrics = calculate_metrics(&returns);

        assert!(metrics.total_return > 0.0);
        assert!(metrics.sharpe_ratio.is_finite());
        assert!(metrics.max_drawdown <= 0.0);
    }
}

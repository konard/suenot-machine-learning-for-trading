//! Pattern-based trading strategy
//!
//! Uses Matching Network pattern classification to generate trading signals.

use crate::data::{MarketPattern, MarketFeatures, FeatureExtractor, OHLCVBar};
use crate::network::MatchingNetwork;
use ndarray::{Array1, Array2};

/// Trading signal generated by the strategy
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum TradingSignal {
    /// Buy/Long signal
    Buy,
    /// Sell/Short signal
    Sell,
    /// Hold current position
    Hold,
    /// Exit all positions
    Exit,
}

impl TradingSignal {
    /// Check if this is an entry signal
    pub fn is_entry(&self) -> bool {
        matches!(self, TradingSignal::Buy | TradingSignal::Sell)
    }

    /// Check if this is an exit signal
    pub fn is_exit(&self) -> bool {
        matches!(self, TradingSignal::Exit)
    }

    /// Get the direction as a multiplier (-1, 0, or 1)
    pub fn direction(&self) -> i32 {
        match self {
            TradingSignal::Buy => 1,
            TradingSignal::Sell => -1,
            TradingSignal::Hold | TradingSignal::Exit => 0,
        }
    }
}

/// Current position state
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Position {
    /// No position
    Flat,
    /// Long position
    Long,
    /// Short position
    Short,
}

impl Position {
    /// Check if currently in a position
    pub fn is_open(&self) -> bool {
        !matches!(self, Position::Flat)
    }
}

/// Result of a trade
#[derive(Debug, Clone)]
pub struct TradeResult {
    /// Entry timestamp
    pub entry_time: i64,
    /// Exit timestamp
    pub exit_time: i64,
    /// Entry price
    pub entry_price: f64,
    /// Exit price
    pub exit_price: f64,
    /// Position direction
    pub position: Position,
    /// Profit/Loss percentage
    pub pnl_pct: f64,
    /// Pattern that triggered entry
    pub entry_pattern: MarketPattern,
    /// Confidence at entry
    pub entry_confidence: f64,
}

/// Pattern-based trading strategy
pub struct PatternTradingStrategy {
    /// The matching network model
    network: MatchingNetwork,
    /// Feature extractor
    feature_extractor: FeatureExtractor,
    /// Support set features
    support_features: Option<Array2<f64>>,
    /// Support set labels
    support_labels: Option<Array1<usize>>,
    /// Minimum confidence for trading
    min_confidence: f64,
    /// Current position
    position: Position,
    /// Entry price for current position
    entry_price: Option<f64>,
    /// Entry time for current position
    entry_time: Option<i64>,
    /// Entry pattern for current position
    entry_pattern: Option<MarketPattern>,
    /// Entry confidence
    entry_confidence: Option<f64>,
    /// Trade history
    trades: Vec<TradeResult>,
}

impl PatternTradingStrategy {
    /// Create a new pattern trading strategy
    ///
    /// # Arguments
    /// * `network` - Trained matching network
    /// * `min_confidence` - Minimum confidence threshold for trades
    ///
    /// # Example
    /// ```
    /// use matching_networks_finance::{MatchingNetwork, PatternTradingStrategy};
    ///
    /// let network = MatchingNetwork::new(20, 64, 32, true);
    /// let strategy = PatternTradingStrategy::new(network, 0.7);
    /// ```
    pub fn new(network: MatchingNetwork, min_confidence: f64) -> Self {
        Self {
            network,
            feature_extractor: FeatureExtractor::new(),
            support_features: None,
            support_labels: None,
            min_confidence,
            position: Position::Flat,
            entry_price: None,
            entry_time: None,
            entry_pattern: None,
            entry_confidence: None,
            trades: Vec::new(),
        }
    }

    /// Set the support set for classification
    pub fn set_support_set(&mut self, features: Array2<f64>, labels: Array1<usize>) {
        self.support_features = Some(features);
        self.support_labels = Some(labels);
    }

    /// Generate trading signal from OHLCV bars
    pub fn generate_signal(&self, bars: &[OHLCVBar]) -> Option<(TradingSignal, MarketPattern, f64)> {
        // Extract features
        let features = self.feature_extractor.extract(bars)?;

        // Get support set
        let support_features = self.support_features.as_ref()?;
        let support_labels = self.support_labels.as_ref()?;

        // Convert to 2D array for network
        let query_features = features.features.clone().insert_axis(ndarray::Axis(0));

        // Predict with confidence
        let (predictions, confidences) = self.network.predict_with_confidence(
            support_features,
            support_labels,
            &query_features,
        );

        let prediction = predictions[0];
        let confidence = confidences[0];

        // Convert to pattern
        let pattern = MarketPattern::from_index(prediction)?;

        // Generate signal based on pattern and confidence
        let signal = if confidence >= self.min_confidence {
            self.pattern_to_signal(pattern)
        } else {
            TradingSignal::Hold
        };

        Some((signal, pattern, confidence))
    }

    /// Process a new bar and potentially execute trades
    pub fn on_bar(&mut self, bars: &[OHLCVBar]) -> Option<TradingSignal> {
        let (signal, pattern, confidence) = self.generate_signal(bars)?;
        let current_bar = bars.last()?;

        // Handle signal based on current position
        let effective_signal = match (&self.position, &signal) {
            // Entry signals when flat
            (Position::Flat, TradingSignal::Buy) => {
                self.open_position(Position::Long, current_bar, pattern, confidence);
                signal
            }
            (Position::Flat, TradingSignal::Sell) => {
                self.open_position(Position::Short, current_bar, pattern, confidence);
                signal
            }

            // Exit signals when in position
            (Position::Long, TradingSignal::Sell) |
            (Position::Long, TradingSignal::Exit) => {
                self.close_position(current_bar);
                signal
            }
            (Position::Short, TradingSignal::Buy) |
            (Position::Short, TradingSignal::Exit) => {
                self.close_position(current_bar);
                signal
            }

            // Hold or same direction - do nothing
            _ => TradingSignal::Hold,
        };

        Some(effective_signal)
    }

    /// Open a new position
    fn open_position(
        &mut self,
        position: Position,
        bar: &OHLCVBar,
        pattern: MarketPattern,
        confidence: f64,
    ) {
        self.position = position;
        self.entry_price = Some(bar.close);
        self.entry_time = Some(bar.timestamp);
        self.entry_pattern = Some(pattern);
        self.entry_confidence = Some(confidence);
    }

    /// Close current position
    fn close_position(&mut self, bar: &OHLCVBar) {
        if let (Some(entry_price), Some(entry_time), Some(pattern), Some(confidence)) = (
            self.entry_price,
            self.entry_time,
            self.entry_pattern,
            self.entry_confidence,
        ) {
            let pnl_pct = match self.position {
                Position::Long => (bar.close - entry_price) / entry_price,
                Position::Short => (entry_price - bar.close) / entry_price,
                Position::Flat => 0.0,
            };

            self.trades.push(TradeResult {
                entry_time,
                exit_time: bar.timestamp,
                entry_price,
                exit_price: bar.close,
                position: self.position,
                pnl_pct,
                entry_pattern: pattern,
                entry_confidence: confidence,
            });
        }

        // Reset position state
        self.position = Position::Flat;
        self.entry_price = None;
        self.entry_time = None;
        self.entry_pattern = None;
        self.entry_confidence = None;
    }

    /// Convert pattern to trading signal
    fn pattern_to_signal(&self, pattern: MarketPattern) -> TradingSignal {
        match pattern {
            MarketPattern::TrendContinuation => {
                // Follow the trend - need to know direction
                // For simplicity, assume uptrend continuation = buy
                TradingSignal::Buy
            }
            MarketPattern::TrendReversal => {
                // Reverse - exit current position
                TradingSignal::Exit
            }
            MarketPattern::Breakout => {
                // Enter on breakout
                TradingSignal::Buy
            }
            MarketPattern::FalseBreakout => {
                // Fade the breakout
                TradingSignal::Sell
            }
            MarketPattern::Consolidation => {
                // Wait during consolidation
                TradingSignal::Hold
            }
        }
    }

    /// Get current position
    pub fn position(&self) -> Position {
        self.position
    }

    /// Get trade history
    pub fn trades(&self) -> &[TradeResult] {
        &self.trades
    }

    /// Calculate total return
    pub fn total_return(&self) -> f64 {
        let mut total = 1.0;
        for trade in &self.trades {
            total *= 1.0 + trade.pnl_pct;
        }
        total - 1.0
    }

    /// Calculate win rate
    pub fn win_rate(&self) -> f64 {
        if self.trades.is_empty() {
            return 0.0;
        }
        let wins = self.trades.iter().filter(|t| t.pnl_pct > 0.0).count();
        wins as f64 / self.trades.len() as f64
    }

    /// Calculate average return per trade
    pub fn avg_return(&self) -> f64 {
        if self.trades.is_empty() {
            return 0.0;
        }
        self.trades.iter().map(|t| t.pnl_pct).sum::<f64>() / self.trades.len() as f64
    }

    /// Get minimum confidence threshold
    pub fn min_confidence(&self) -> f64 {
        self.min_confidence
    }

    /// Set minimum confidence threshold
    pub fn set_min_confidence(&mut self, confidence: f64) {
        self.min_confidence = confidence;
    }

    /// Reset strategy state
    pub fn reset(&mut self) {
        self.position = Position::Flat;
        self.entry_price = None;
        self.entry_time = None;
        self.entry_pattern = None;
        self.entry_confidence = None;
        self.trades.clear();
    }

    /// Get performance summary
    pub fn summary(&self) -> PerformanceSummary {
        PerformanceSummary {
            total_trades: self.trades.len(),
            winning_trades: self.trades.iter().filter(|t| t.pnl_pct > 0.0).count(),
            losing_trades: self.trades.iter().filter(|t| t.pnl_pct < 0.0).count(),
            total_return: self.total_return(),
            win_rate: self.win_rate(),
            avg_return: self.avg_return(),
            max_drawdown: self.calculate_max_drawdown(),
            sharpe_ratio: self.calculate_sharpe_ratio(),
        }
    }

    /// Calculate maximum drawdown
    fn calculate_max_drawdown(&self) -> f64 {
        let mut peak = 1.0;
        let mut max_dd = 0.0;
        let mut equity = 1.0;

        for trade in &self.trades {
            equity *= 1.0 + trade.pnl_pct;
            if equity > peak {
                peak = equity;
            }
            let dd = (peak - equity) / peak;
            if dd > max_dd {
                max_dd = dd;
            }
        }

        max_dd
    }

    /// Calculate Sharpe ratio (simplified, assuming 0 risk-free rate)
    fn calculate_sharpe_ratio(&self) -> f64 {
        if self.trades.len() < 2 {
            return 0.0;
        }

        let returns: Vec<f64> = self.trades.iter().map(|t| t.pnl_pct).collect();
        let mean = returns.iter().sum::<f64>() / returns.len() as f64;
        let variance: f64 = returns.iter().map(|r| (r - mean).powi(2)).sum::<f64>()
            / (returns.len() - 1) as f64;
        let std_dev = variance.sqrt();

        if std_dev > 0.0 {
            mean / std_dev * (252.0_f64).sqrt() // Annualized
        } else {
            0.0
        }
    }
}

/// Performance summary
#[derive(Debug, Clone)]
pub struct PerformanceSummary {
    pub total_trades: usize,
    pub winning_trades: usize,
    pub losing_trades: usize,
    pub total_return: f64,
    pub win_rate: f64,
    pub avg_return: f64,
    pub max_drawdown: f64,
    pub sharpe_ratio: f64,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_trading_signal() {
        assert!(TradingSignal::Buy.is_entry());
        assert!(TradingSignal::Sell.is_entry());
        assert!(!TradingSignal::Hold.is_entry());
        assert!(TradingSignal::Exit.is_exit());

        assert_eq!(TradingSignal::Buy.direction(), 1);
        assert_eq!(TradingSignal::Sell.direction(), -1);
        assert_eq!(TradingSignal::Hold.direction(), 0);
    }

    #[test]
    fn test_position() {
        assert!(!Position::Flat.is_open());
        assert!(Position::Long.is_open());
        assert!(Position::Short.is_open());
    }

    #[test]
    fn test_strategy_creation() {
        let network = MatchingNetwork::new(20, 64, 32, true);
        let strategy = PatternTradingStrategy::new(network, 0.7);

        assert_eq!(strategy.position(), Position::Flat);
        assert!(strategy.trades().is_empty());
        assert_eq!(strategy.min_confidence(), 0.7);
    }

    #[test]
    fn test_pattern_to_signal() {
        let network = MatchingNetwork::new(20, 64, 32, false);
        let strategy = PatternTradingStrategy::new(network, 0.7);

        // Test pattern mapping
        assert_eq!(
            strategy.pattern_to_signal(MarketPattern::TrendContinuation),
            TradingSignal::Buy
        );
        assert_eq!(
            strategy.pattern_to_signal(MarketPattern::TrendReversal),
            TradingSignal::Exit
        );
        assert_eq!(
            strategy.pattern_to_signal(MarketPattern::Consolidation),
            TradingSignal::Hold
        );
    }

    #[test]
    fn test_performance_metrics() {
        let network = MatchingNetwork::new(20, 64, 32, false);
        let mut strategy = PatternTradingStrategy::new(network, 0.5);

        // Add some mock trades
        strategy.trades.push(TradeResult {
            entry_time: 0,
            exit_time: 1,
            entry_price: 100.0,
            exit_price: 105.0,
            position: Position::Long,
            pnl_pct: 0.05,
            entry_pattern: MarketPattern::Breakout,
            entry_confidence: 0.8,
        });

        strategy.trades.push(TradeResult {
            entry_time: 2,
            exit_time: 3,
            entry_price: 105.0,
            exit_price: 103.0,
            position: Position::Long,
            pnl_pct: -0.019,
            entry_pattern: MarketPattern::TrendContinuation,
            entry_confidence: 0.75,
        });

        assert_eq!(strategy.trades().len(), 2);
        assert_eq!(strategy.win_rate(), 0.5);
        assert!(strategy.total_return() > 0.0);
    }
}

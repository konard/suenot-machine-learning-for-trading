"""
Backtesting framework for LLM-based trading signals.

This module provides tools for evaluating trading strategies
based on signals generated by fine-tuned LLMs.
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Any, Optional, Tuple, Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from collections import defaultdict

from .signals import TradingSignal, TradingSignalGenerator


@dataclass
class Position:
    """Represents an open trading position."""
    symbol: str
    side: str  # "long" or "short"
    entry_price: float
    entry_time: datetime
    size: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None

    @property
    def is_long(self) -> bool:
        return self.side == "long"

    def pnl(self, current_price: float) -> float:
        """Calculate unrealized P&L."""
        if self.is_long:
            return (current_price - self.entry_price) * self.size
        else:
            return (self.entry_price - current_price) * self.size

    def pnl_percent(self, current_price: float) -> float:
        """Calculate P&L as percentage."""
        if self.is_long:
            return (current_price - self.entry_price) / self.entry_price
        else:
            return (self.entry_price - current_price) / self.entry_price


@dataclass
class Trade:
    """Represents a completed trade."""
    symbol: str
    side: str
    entry_price: float
    exit_price: float
    entry_time: datetime
    exit_time: datetime
    size: float
    pnl: float
    pnl_percent: float
    signal_confidence: float
    signal_direction: str

    @property
    def is_winner(self) -> bool:
        return self.pnl > 0

    @property
    def duration(self) -> timedelta:
        return self.exit_time - self.entry_time


@dataclass
class BacktestResult:
    """Results from backtesting."""
    total_return: float
    sharpe_ratio: float
    sortino_ratio: float
    max_drawdown: float
    win_rate: float
    profit_factor: float
    num_trades: int
    avg_trade_return: float
    avg_winner: float
    avg_loser: float
    best_trade: float
    worst_trade: float
    total_days: int
    trades: List[Trade] = field(default_factory=list)
    equity_curve: pd.Series = field(default_factory=pd.Series)
    daily_returns: pd.Series = field(default_factory=pd.Series)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "total_return": self.total_return,
            "sharpe_ratio": self.sharpe_ratio,
            "sortino_ratio": self.sortino_ratio,
            "max_drawdown": self.max_drawdown,
            "win_rate": self.win_rate,
            "profit_factor": self.profit_factor,
            "num_trades": self.num_trades,
            "avg_trade_return": self.avg_trade_return,
            "avg_winner": self.avg_winner,
            "avg_loser": self.avg_loser,
            "best_trade": self.best_trade,
            "worst_trade": self.worst_trade,
            "total_days": self.total_days
        }


class LLMBacktester:
    """
    Backtester for LLM-based trading strategies.

    Simulates trading based on signals from a fine-tuned LLM,
    computing comprehensive performance metrics.

    Example:
        >>> backtester = LLMBacktester(model_path="outputs/model")
        >>> results = backtester.run(price_data, news_data)
        >>> print(f"Sharpe: {results.sharpe_ratio:.2f}")
    """

    def __init__(
        self,
        model_path: Optional[str] = None,
        signal_generator: Optional[TradingSignalGenerator] = None,
        initial_capital: float = 100000,
        position_size: float = 0.1,
        max_positions: int = 5,
        confidence_threshold: float = 0.7,
        stop_loss: Optional[float] = 0.02,
        take_profit: Optional[float] = 0.05,
        commission: float = 0.001
    ):
        """
        Initialize backtester.

        Args:
            model_path: Path to saved model (if signal_generator not provided)
            signal_generator: Pre-initialized signal generator
            initial_capital: Starting capital
            position_size: Fraction of capital per trade
            max_positions: Maximum concurrent positions
            confidence_threshold: Minimum signal confidence to trade
            stop_loss: Stop loss percentage (None to disable)
            take_profit: Take profit percentage (None to disable)
            commission: Commission per trade (as fraction)
        """
        if signal_generator:
            self.signal_generator = signal_generator
        elif model_path:
            self.signal_generator = TradingSignalGenerator.from_pretrained(model_path)
        else:
            # Create default for testing
            from .model import FinancialSentimentLoRA
            model = FinancialSentimentLoRA()
            self.signal_generator = TradingSignalGenerator(
                model,
                confidence_threshold=confidence_threshold
            )

        self.initial_capital = initial_capital
        self.position_size = position_size
        self.max_positions = max_positions
        self.confidence_threshold = confidence_threshold
        self.stop_loss = stop_loss
        self.take_profit = take_profit
        self.commission = commission

    def run(
        self,
        price_data: pd.DataFrame,
        news_data: Optional[pd.DataFrame] = None,
        signal_aggregation: str = "confidence_weighted"
    ) -> BacktestResult:
        """
        Run backtest simulation.

        Args:
            price_data: DataFrame with OHLCV data (index=datetime)
            news_data: Optional DataFrame with columns: timestamp, text
            signal_aggregation: Method for aggregating multiple signals

        Returns:
            BacktestResult with performance metrics
        """
        # Prepare data
        if news_data is None:
            # Generate dummy signals if no news
            news_data = self._generate_dummy_news(price_data)

        # Initialize state
        capital = self.initial_capital
        positions: Dict[str, Position] = {}
        trades: List[Trade] = []
        equity_curve = []
        daily_returns = []

        # Align news with price data
        price_data = price_data.copy()
        if "close" not in price_data.columns and "Close" in price_data.columns:
            price_data = price_data.rename(columns=lambda x: x.lower())

        # Track signals by date
        date_signals = self._group_signals_by_date(news_data, price_data.index)

        prev_equity = capital

        # Iterate through each trading day
        for timestamp, row in price_data.iterrows():
            current_price = row["close"]
            date_key = timestamp.date() if hasattr(timestamp, "date") else timestamp

            # Update position P&L and check stops
            for symbol in list(positions.keys()):
                position = positions[symbol]
                pnl_pct = position.pnl_percent(current_price)

                # Check stop loss
                if self.stop_loss and pnl_pct <= -self.stop_loss:
                    trade = self._close_position(
                        position, current_price, timestamp, "stop_loss"
                    )
                    trades.append(trade)
                    capital += trade.pnl - abs(trade.pnl * self.commission)
                    del positions[symbol]

                # Check take profit
                elif self.take_profit and pnl_pct >= self.take_profit:
                    trade = self._close_position(
                        position, current_price, timestamp, "take_profit"
                    )
                    trades.append(trade)
                    capital += trade.pnl - abs(trade.pnl * self.commission)
                    del positions[symbol]

            # Get signals for this date
            signals = date_signals.get(date_key, [])

            if signals:
                # Aggregate signals
                aggregate = self.signal_generator.aggregate_signals(
                    signals, method=signal_aggregation
                )

                # Execute based on aggregate signal
                if aggregate["actionable"]:
                    direction = aggregate["direction"]
                    confidence = aggregate["confidence"]

                    # Check if we should trade
                    if len(positions) < self.max_positions:
                        if direction == "BUY" and "default" not in positions:
                            # Open long position
                            size = capital * self.position_size / current_price
                            position = Position(
                                symbol="default",
                                side="long",
                                entry_price=current_price,
                                entry_time=timestamp,
                                size=size
                            )
                            positions["default"] = position
                            capital -= size * current_price * self.commission

                        elif direction == "SELL" and "default" in positions:
                            # Close long position
                            position = positions["default"]
                            if position.is_long:
                                trade = self._close_position(
                                    position, current_price, timestamp, "signal"
                                )
                                trade.signal_confidence = confidence
                                trade.signal_direction = direction
                                trades.append(trade)
                                capital += trade.pnl - abs(trade.pnl * self.commission)
                                del positions["default"]

            # Calculate current equity
            equity = capital
            for position in positions.values():
                equity += position.pnl(current_price)

            equity_curve.append({"timestamp": timestamp, "equity": equity})

            # Daily return
            if prev_equity > 0:
                daily_ret = (equity - prev_equity) / prev_equity
                daily_returns.append({"timestamp": timestamp, "return": daily_ret})
            prev_equity = equity

        # Close remaining positions
        if positions and len(price_data) > 0:
            final_price = price_data.iloc[-1]["close"]
            final_time = price_data.index[-1]
            for symbol, position in positions.items():
                trade = self._close_position(
                    position, final_price, final_time, "end_of_backtest"
                )
                trades.append(trade)

        # Compute metrics
        equity_df = pd.DataFrame(equity_curve)
        if not equity_df.empty:
            equity_df = equity_df.set_index("timestamp")["equity"]
        else:
            equity_df = pd.Series([self.initial_capital])

        returns_df = pd.DataFrame(daily_returns)
        if not returns_df.empty:
            returns_df = returns_df.set_index("timestamp")["return"]
        else:
            returns_df = pd.Series([0.0])

        return self._compute_results(trades, equity_df, returns_df, len(price_data))

    def _generate_dummy_news(self, price_data: pd.DataFrame) -> pd.DataFrame:
        """Generate dummy news based on price movements."""
        records = []
        prev_close = None

        for timestamp, row in price_data.iterrows():
            current_close = row.get("close", row.get("Close"))

            if prev_close is not None:
                ret = (current_close - prev_close) / prev_close

                if ret > 0.01:
                    text = "Strong buying pressure drives prices higher"
                elif ret < -0.01:
                    text = "Selling pressure pushes prices lower"
                else:
                    text = "Market consolidates in narrow range"

                records.append({"timestamp": timestamp, "text": text})

            prev_close = current_close

        return pd.DataFrame(records)

    def _group_signals_by_date(
        self,
        news_data: pd.DataFrame,
        index: pd.DatetimeIndex
    ) -> Dict[Any, List[TradingSignal]]:
        """Group and generate signals by date."""
        signals_by_date = defaultdict(list)

        for _, row in news_data.iterrows():
            timestamp = row["timestamp"]
            text = row["text"]

            signal = self.signal_generator.generate(text)

            if hasattr(timestamp, "date"):
                date_key = timestamp.date()
            else:
                date_key = timestamp

            signals_by_date[date_key].append(signal)

        return signals_by_date

    def _close_position(
        self,
        position: Position,
        exit_price: float,
        exit_time: datetime,
        reason: str
    ) -> Trade:
        """Close position and create trade record."""
        pnl = position.pnl(exit_price)
        pnl_pct = position.pnl_percent(exit_price)

        return Trade(
            symbol=position.symbol,
            side=position.side,
            entry_price=position.entry_price,
            exit_price=exit_price,
            entry_time=position.entry_time,
            exit_time=exit_time,
            size=position.size,
            pnl=pnl,
            pnl_percent=pnl_pct,
            signal_confidence=0.0,
            signal_direction=reason
        )

    def _compute_results(
        self,
        trades: List[Trade],
        equity_curve: pd.Series,
        daily_returns: pd.Series,
        total_days: int
    ) -> BacktestResult:
        """Compute backtest performance metrics."""
        # Total return
        if len(equity_curve) > 0:
            total_return = (equity_curve.iloc[-1] - self.initial_capital) / self.initial_capital
        else:
            total_return = 0.0

        # Trade statistics
        if trades:
            winners = [t for t in trades if t.is_winner]
            losers = [t for t in trades if not t.is_winner]

            win_rate = len(winners) / len(trades)
            avg_trade_return = np.mean([t.pnl_percent for t in trades])
            avg_winner = np.mean([t.pnl_percent for t in winners]) if winners else 0
            avg_loser = np.mean([t.pnl_percent for t in losers]) if losers else 0
            best_trade = max(t.pnl_percent for t in trades)
            worst_trade = min(t.pnl_percent for t in trades)

            # Profit factor
            gross_profit = sum(t.pnl for t in winners)
            gross_loss = abs(sum(t.pnl for t in losers))
            profit_factor = gross_profit / gross_loss if gross_loss > 0 else float("inf")
        else:
            win_rate = 0.0
            avg_trade_return = 0.0
            avg_winner = 0.0
            avg_loser = 0.0
            best_trade = 0.0
            worst_trade = 0.0
            profit_factor = 0.0

        # Risk metrics from daily returns
        if len(daily_returns) > 1:
            returns_array = daily_returns.values
            avg_return = np.mean(returns_array)
            std_return = np.std(returns_array)

            # Sharpe ratio (annualized, assuming 252 trading days)
            sharpe_ratio = (avg_return * 252) / (std_return * np.sqrt(252)) if std_return > 0 else 0

            # Sortino ratio (downside deviation)
            negative_returns = returns_array[returns_array < 0]
            downside_std = np.std(negative_returns) if len(negative_returns) > 0 else std_return
            sortino_ratio = (avg_return * 252) / (downside_std * np.sqrt(252)) if downside_std > 0 else 0

            # Maximum drawdown
            cumulative = (1 + daily_returns).cumprod()
            rolling_max = cumulative.cummax()
            drawdowns = (cumulative - rolling_max) / rolling_max
            max_drawdown = abs(drawdowns.min())
        else:
            sharpe_ratio = 0.0
            sortino_ratio = 0.0
            max_drawdown = 0.0

        return BacktestResult(
            total_return=total_return,
            sharpe_ratio=sharpe_ratio,
            sortino_ratio=sortino_ratio,
            max_drawdown=max_drawdown,
            win_rate=win_rate,
            profit_factor=profit_factor,
            num_trades=len(trades),
            avg_trade_return=avg_trade_return,
            avg_winner=avg_winner,
            avg_loser=avg_loser,
            best_trade=best_trade,
            worst_trade=worst_trade,
            total_days=total_days,
            trades=trades,
            equity_curve=equity_curve,
            daily_returns=daily_returns
        )

    def analyze_signals(
        self,
        news_data: pd.DataFrame,
        price_data: pd.DataFrame
    ) -> pd.DataFrame:
        """
        Analyze signal accuracy against subsequent price movements.

        Args:
            news_data: DataFrame with timestamp and text columns
            price_data: DataFrame with OHLCV data

        Returns:
            DataFrame with signal analysis
        """
        records = []

        for _, row in news_data.iterrows():
            timestamp = row["timestamp"]
            text = row["text"]

            signal = self.signal_generator.generate(text)

            # Find subsequent return
            if hasattr(timestamp, "date"):
                date = timestamp.date()
            else:
                date = timestamp

            # Get next day's return
            try:
                idx = price_data.index.get_loc(date)
                if idx + 1 < len(price_data):
                    current_price = price_data.iloc[idx]["close"]
                    next_price = price_data.iloc[idx + 1]["close"]
                    next_return = (next_price - current_price) / current_price
                else:
                    next_return = 0.0
            except (KeyError, IndexError):
                next_return = 0.0

            # Check if signal was correct
            signal_numeric = {"SELL": -1, "HOLD": 0, "BUY": 1}[signal.direction]
            actual_direction = 1 if next_return > 0 else -1 if next_return < 0 else 0
            correct = signal_numeric == actual_direction or signal_numeric == 0

            records.append({
                "timestamp": timestamp,
                "text": text[:50] + "...",
                "signal": signal.direction,
                "confidence": signal.confidence,
                "next_return": next_return,
                "actual_direction": "UP" if actual_direction > 0 else "DOWN" if actual_direction < 0 else "FLAT",
                "correct": correct,
                "profit_if_followed": signal_numeric * next_return
            })

        return pd.DataFrame(records)


def run_walk_forward(
    backtester: LLMBacktester,
    price_data: pd.DataFrame,
    news_data: pd.DataFrame,
    train_period: int = 252,  # ~1 year
    test_period: int = 63,    # ~3 months
) -> List[BacktestResult]:
    """
    Run walk-forward optimization/validation.

    Args:
        backtester: Configured backtester
        price_data: Full price history
        news_data: Full news history
        train_period: Training window size (days)
        test_period: Testing window size (days)

    Returns:
        List of BacktestResult for each test period
    """
    results = []
    start_idx = train_period

    while start_idx + test_period <= len(price_data):
        # Get test period data
        test_start = start_idx
        test_end = start_idx + test_period

        test_prices = price_data.iloc[test_start:test_end]

        # Filter news for test period
        test_start_time = test_prices.index[0]
        test_end_time = test_prices.index[-1]

        test_news = news_data[
            (news_data["timestamp"] >= test_start_time) &
            (news_data["timestamp"] <= test_end_time)
        ]

        # Run backtest on test period
        result = backtester.run(test_prices, test_news)
        results.append(result)

        # Move forward
        start_idx += test_period

    return results


if __name__ == "__main__":
    # Example usage
    print("Testing LLM Backtester...")

    # Create dummy price data
    dates = pd.date_range(start="2023-01-01", periods=252, freq="B")
    np.random.seed(42)
    returns = np.random.randn(252) * 0.01
    prices = 100 * np.cumprod(1 + returns)

    price_data = pd.DataFrame({
        "open": prices * (1 + np.random.randn(252) * 0.005),
        "high": prices * (1 + abs(np.random.randn(252) * 0.01)),
        "low": prices * (1 - abs(np.random.randn(252) * 0.01)),
        "close": prices,
        "volume": np.random.randint(1000000, 10000000, 252)
    }, index=dates)

    # Create backtester
    backtester = LLMBacktester(
        initial_capital=100000,
        position_size=0.1,
        confidence_threshold=0.6
    )

    # Run backtest
    results = backtester.run(price_data)

    print(f"\nBacktest Results:")
    print(f"Total Return: {results.total_return:.2%}")
    print(f"Sharpe Ratio: {results.sharpe_ratio:.2f}")
    print(f"Max Drawdown: {results.max_drawdown:.2%}")
    print(f"Win Rate: {results.win_rate:.2%}")
    print(f"Profit Factor: {results.profit_factor:.2f}")
    print(f"Number of Trades: {results.num_trades}")

//! News-based trading strategy implementation

use crate::analysis::{AggregatedSignal, SignalAggregator};
use crate::llm::NewsAnalyzer;
use crate::news::{NewsCollector, NewsItem};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Configuration for news trading strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategyConfig {
    /// Target symbols to trade
    pub symbols: Vec<String>,
    /// Minimum signal strength to act on
    pub min_signal_strength: f64,
    /// Minimum confidence to act on
    pub min_confidence: f64,
    /// Maximum position size as fraction of portfolio
    pub max_position_size: f64,
    /// Cooldown period between trades (seconds)
    pub trade_cooldown_secs: i64,
    /// Enable short selling
    pub allow_shorts: bool,
    /// Maximum number of concurrent positions
    pub max_positions: usize,
}

impl Default for StrategyConfig {
    fn default() -> Self {
        Self {
            symbols: vec!["BTC".to_string(), "ETH".to_string()],
            min_signal_strength: 0.3,
            min_confidence: 0.6,
            max_position_size: 0.1,
            trade_cooldown_secs: 300,
            allow_shorts: false,
            max_positions: 5,
        }
    }
}

/// Trading signal generated by the strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategySignal {
    /// Symbol to trade
    pub symbol: String,
    /// Action to take
    pub action: TradeAction,
    /// Signal strength (0.0 to 1.0)
    pub strength: f64,
    /// Confidence in signal
    pub confidence: f64,
    /// Suggested position size (fraction of portfolio)
    pub position_size: f64,
    /// Reason for the signal
    pub reason: String,
    /// Timestamp
    pub timestamp: DateTime<Utc>,
    /// Contributing news IDs
    pub news_ids: Vec<String>,
}

/// Trade action type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum TradeAction {
    /// Open long position
    Buy,
    /// Close long position
    Sell,
    /// Open short position
    Short,
    /// Close short position
    Cover,
    /// No action
    Hold,
}

/// News-based trading strategy
pub struct NewsStrategy {
    config: StrategyConfig,
    aggregator: SignalAggregator,
    last_trade_time: HashMap<String, DateTime<Utc>>,
    active_positions: HashMap<String, PositionState>,
}

/// Simple position state tracking
#[derive(Debug, Clone)]
struct PositionState {
    side: PositionSide,
    entry_time: DateTime<Utc>,
    entry_signal_strength: f64,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum PositionSide {
    Long,
    Short,
    None,
}

impl NewsStrategy {
    /// Create a new news strategy with configuration
    pub fn new(config: StrategyConfig) -> Self {
        Self {
            config,
            aggregator: SignalAggregator::new(),
            last_trade_time: HashMap::new(),
            active_positions: HashMap::new(),
        }
    }

    /// Create with default configuration
    pub fn default_config() -> Self {
        Self::new(StrategyConfig::default())
    }

    /// Process aggregated signal and generate trading signal
    pub fn process_signal(&mut self, agg_signal: &AggregatedSignal) -> Option<StrategySignal> {
        let symbol = &agg_signal.symbol;
        let now = Utc::now();

        // Check cooldown
        if let Some(last_time) = self.last_trade_time.get(symbol) {
            let elapsed = (now - *last_time).num_seconds();
            if elapsed < self.config.trade_cooldown_secs {
                tracing::debug!(
                    "Symbol {} in cooldown ({} secs remaining)",
                    symbol,
                    self.config.trade_cooldown_secs - elapsed
                );
                return None;
            }
        }

        // Check minimum thresholds
        if agg_signal.strength < self.config.min_signal_strength {
            tracing::debug!(
                "Signal strength {} below threshold {}",
                agg_signal.strength,
                self.config.min_signal_strength
            );
            return None;
        }

        if agg_signal.confidence < self.config.min_confidence {
            tracing::debug!(
                "Confidence {} below threshold {}",
                agg_signal.confidence,
                self.config.min_confidence
            );
            return None;
        }

        // Determine action based on current position and signal
        let current_position = self
            .active_positions
            .get(symbol)
            .map(|p| p.side)
            .unwrap_or(PositionSide::None);

        let (action, reason) = self.determine_action(agg_signal, current_position);

        if action == TradeAction::Hold {
            return None;
        }

        // Calculate position size
        let position_size = self.calculate_position_size(agg_signal);

        // Update state
        self.last_trade_time.insert(symbol.clone(), now);
        self.update_position_state(symbol, &action, agg_signal.strength);

        let news_ids = agg_signal
            .components
            .iter()
            .map(|c| c.news_id.clone())
            .collect();

        Some(StrategySignal {
            symbol: symbol.clone(),
            action,
            strength: agg_signal.strength,
            confidence: agg_signal.confidence,
            position_size,
            reason,
            timestamp: now,
            news_ids,
        })
    }

    /// Determine trade action based on signal and current position
    fn determine_action(
        &self,
        signal: &AggregatedSignal,
        current_position: PositionSide,
    ) -> (TradeAction, String) {
        let is_bullish = signal.sentiment > 0.0;
        let is_strong = signal.strength > 0.5;

        match (current_position, is_bullish) {
            // No position - consider opening
            (PositionSide::None, true) => {
                let reason = format!(
                    "Bullish signal (sentiment: {:.2}, strength: {:.2}) from {} news items",
                    signal.sentiment, signal.strength, signal.news_count
                );
                (TradeAction::Buy, reason)
            }
            (PositionSide::None, false) if self.config.allow_shorts && is_strong => {
                let reason = format!(
                    "Strong bearish signal (sentiment: {:.2}) from {} news items",
                    signal.sentiment, signal.news_count
                );
                (TradeAction::Short, reason)
            }

            // Have long position
            (PositionSide::Long, false) if is_strong => {
                let reason = format!(
                    "Closing long due to bearish signal (sentiment: {:.2})",
                    signal.sentiment
                );
                (TradeAction::Sell, reason)
            }

            // Have short position
            (PositionSide::Short, true) if is_strong => {
                let reason = format!(
                    "Closing short due to bullish signal (sentiment: {:.2})",
                    signal.sentiment
                );
                (TradeAction::Cover, reason)
            }

            _ => (TradeAction::Hold, "No action needed".to_string()),
        }
    }

    /// Calculate position size based on signal and config
    fn calculate_position_size(&self, signal: &AggregatedSignal) -> f64 {
        let base_size = self.config.max_position_size;
        let strength_factor = signal.strength;
        let confidence_factor = signal.confidence;

        (base_size * strength_factor * confidence_factor).min(self.config.max_position_size)
    }

    /// Update internal position state
    fn update_position_state(&mut self, symbol: &str, action: &TradeAction, strength: f64) {
        match action {
            TradeAction::Buy => {
                self.active_positions.insert(
                    symbol.to_string(),
                    PositionState {
                        side: PositionSide::Long,
                        entry_time: Utc::now(),
                        entry_signal_strength: strength,
                    },
                );
            }
            TradeAction::Short => {
                self.active_positions.insert(
                    symbol.to_string(),
                    PositionState {
                        side: PositionSide::Short,
                        entry_time: Utc::now(),
                        entry_signal_strength: strength,
                    },
                );
            }
            TradeAction::Sell | TradeAction::Cover => {
                self.active_positions.remove(symbol);
            }
            TradeAction::Hold => {}
        }
    }

    /// Get current active positions count
    pub fn active_position_count(&self) -> usize {
        self.active_positions.len()
    }

    /// Check if symbol has active position
    pub fn has_position(&self, symbol: &str) -> bool {
        self.active_positions.contains_key(symbol)
    }

    /// Get strategy configuration
    pub fn config(&self) -> &StrategyConfig {
        &self.config
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::analysis::{EventType, SignalAction as AnalysisAction};

    fn create_test_signal(symbol: &str, sentiment: f64, confidence: f64) -> AggregatedSignal {
        AggregatedSignal {
            symbol: symbol.to_string(),
            sentiment,
            confidence,
            news_count: 3,
            dominant_event: EventType::Regulatory,
            strength: (sentiment * confidence).abs(),
            action: AnalysisAction::from_sentiment(sentiment * confidence),
            timestamp: Utc::now(),
            components: vec![],
        }
    }

    #[test]
    fn test_strategy_creation() {
        let config = StrategyConfig::default();
        let strategy = NewsStrategy::new(config);
        assert_eq!(strategy.active_position_count(), 0);
    }

    #[test]
    fn test_bullish_signal_generates_buy() {
        let config = StrategyConfig {
            min_signal_strength: 0.2,
            min_confidence: 0.5,
            ..Default::default()
        };
        let mut strategy = NewsStrategy::new(config);

        let signal = create_test_signal("BTC", 0.7, 0.8);
        let result = strategy.process_signal(&signal);

        assert!(result.is_some());
        let trade_signal = result.unwrap();
        assert_eq!(trade_signal.action, TradeAction::Buy);
        assert!(strategy.has_position("BTC"));
    }

    #[test]
    fn test_weak_signal_ignored() {
        let config = StrategyConfig {
            min_signal_strength: 0.5,
            min_confidence: 0.7,
            ..Default::default()
        };
        let mut strategy = NewsStrategy::new(config);

        let signal = create_test_signal("BTC", 0.2, 0.5); // Weak signal
        let result = strategy.process_signal(&signal);

        assert!(result.is_none());
    }

    #[test]
    fn test_cooldown_prevents_rapid_trades() {
        let config = StrategyConfig {
            min_signal_strength: 0.2,
            min_confidence: 0.5,
            trade_cooldown_secs: 300,
            ..Default::default()
        };
        let mut strategy = NewsStrategy::new(config);

        let signal = create_test_signal("BTC", 0.7, 0.8);

        // First trade should succeed
        let result1 = strategy.process_signal(&signal);
        assert!(result1.is_some());

        // Second immediate trade should be blocked by cooldown
        let signal2 = create_test_signal("BTC", -0.7, 0.8);
        let result2 = strategy.process_signal(&signal2);
        assert!(result2.is_none());
    }
}

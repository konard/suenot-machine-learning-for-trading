# Глава 346: Темпоральные Графовые Нейронные Сети для Трейдинга

## Обзор

Темпоральные Графовые Нейронные Сети (Temporal GNN / TGN) представляют собой передовой подход к глубокому обучению на динамических графах, специально разработанный для обучения на последовательностях событий в непрерывном времени. В отличие от статических GNN, которые рассматривают графы как фиксированные структуры, Temporal GNN поддерживают память о прошлых взаимодействиях и кодируют временные паттерны для прогнозирования будущих событий на финансовых рынках.

Эта глава исследует реализацию Temporal Graph Networks для торговли криптовалютами на бирже Bybit, с фокусом на захвате эволюционирующих связей между активами во времени.

## Содержание

1. [Введение](#введение)
2. [Теоретические основы](#теоретические-основы)
3. [Архитектура TGN](#архитектура-tgn)
4. [Модуль памяти](#модуль-памяти)
5. [Функция сообщений](#функция-сообщений)
6. [Кодирование времени](#кодирование-времени)
7. [Подход к обучению](#подход-к-обучению)
8. [Применение к торговле криптовалютами](#применение-к-торговле-криптовалютами)
9. [Стратегия реализации](#стратегия-реализации)
10. [Управление рисками](#управление-рисками)
11. [Метрики производительности](#метрики-производительности)
12. [Литература](#литература)

---

## Введение

Финансовые рынки — это принципиально темпоральные системы, где события происходят в непрерывном времени. Традиционные подходы дискретизируют время в фиксированные интервалы (1-минутные, 1-часовые свечи), теряя ценную информацию о точном времени и последовательности событий. Temporal Graph Neural Networks решают эту проблему:

- **Обучение на потоках событий**: Обработка сделок, обновлений стакана заявок и изменений цен по мере их возникновения
- **Поддержание темпоральной памяти**: Запоминание прошлых взаимодействий для информирования текущих прогнозов
- **Кодирование временной динамики**: Захват сложных временных паттернов, таких как периодичность и затухание
- **Обработка нерегулярной выборки**: Работа с событиями, происходящими в произвольные моменты времени

### Почему Temporal GNN для трейдинга?

```
┌─────────────────────────────────────────────────────────────────────────┐
│                  Непрерывные финансовые события во времени               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Время ──────────────────────────────────────────────────────────────→   │
│                                                                          │
│  BTC:  ●──────●───●────────────●─●──●───────────●────────────●───→      │
│          сделка сделка        сделки           сделка        сделка     │
│                                                                          │
│  ETH:  ───●────────●──●────────────────●──●──●───────●────────────→      │
│          сделка   сделки                сделки       сделка              │
│                                                                          │
│  SOL:  ────────●──────────●────●─────────────●───────────●──●──→        │
│                сделка     сделки            сделка        сделки        │
│                                                                          │
│  TGN: Учится на ВРЕМЕНИ и ПОСЛЕДОВАТЕЛЬНОСТИ всех этих событий!         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### Традиционный подход vs Темпоральный

| Аспект | Традиционный GNN | Temporal GNN |
|--------|------------------|--------------|
| Обработка времени | Дискретные снимки | Непрерывные события |
| Память | Без состояния между снимками | Персистентная память |
| Последовательность событий | Теряется между снимками | Сохраняется |
| Нерегулярность | Требует ресемплинга | Нативная поддержка |
| Задержка | Пакетно-ориентированная | Событийно-управляемая |

## Теоретические основы

### Динамические графы в непрерывном времени

Динамический граф в непрерывном времени (CTDG) определяется как последовательность событий с метками времени:

$$\mathcal{G} = \{(u_1, v_1, t_1, e_1), (u_2, v_2, t_2, e_2), ..., (u_n, v_n, t_n, e_n)\}$$

Где:
- $(u_i, v_i)$ — узлы источника и назначения
- $t_i$ — временная метка (непрерывная)
- $e_i$ — признаки ребра (размер сделки, цена и т.д.)

### Фреймворк TGN

Ключевая идея TGN — поддержание **состояния памяти** для каждого узла, которое обновляется при каждом взаимодействии:

```
┌─────────────────────────────────────────────────────────────────┐
│                   Конвейер обработки TGN                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Событие: (u, v, t, e)                                          │
│           │                                                      │
│           ▼                                                      │
│  ┌────────────────┐                                             │
│  │  Сырые         │ ← Вычисление сообщений из события           │
│  │  сообщения     │                                             │
│  └───────┬────────┘                                             │
│          │                                                       │
│          ▼                                                       │
│  ┌────────────────┐                                             │
│  │  Агрегация     │ ← Объединение сообщений для каждого узла    │
│  └───────┬────────┘                                             │
│          │                                                       │
│          ▼                                                       │
│  ┌────────────────┐                                             │
│  │ Обновление     │ ← s(t) = GRU(s(t⁻), aggregated_msg)         │
│  │ памяти         │                                             │
│  └───────┬────────┘                                             │
│          │                                                       │
│          ▼                                                       │
│  ┌────────────────┐                                             │
│  │  Эмбеддинг     │ ← z(t) = f(s(t), temporal_neighbors)        │
│  └───────┬────────┘                                             │
│          │                                                       │
│          ▼                                                       │
│  ┌────────────────┐                                             │
│  │  Предсказание  │ ← Задача предсказания связей/узлов/графа    │
│  └────────────────┘                                             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Математическая формулировка

Для каждого узла $i$ TGN поддерживает:

1. **Состояние памяти** $s_i(t)$: Сжатое представление прошлых взаимодействий
2. **Темпоральный эмбеддинг** $z_i(t)$: Текущее представление с учетом соседей

Обновление памяти следует формуле:

$$s_i(t) = \text{mem}(s_i(t^-), m_i(t))$$

Где $m_i(t)$ — агрегированное сообщение, а $\text{mem}$ — обучаемая функция (обычно GRU или LSTM).

## Архитектура TGN

### Обзор компонентов

```
┌─────────────────────────────────────────────────────────────────────┐
│                        Архитектура TGN                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐               │
│  │   Модуль    │   │   Функция   │   │   Кодиро-   │               │
│  │   памяти    │   │   сообщений │   │   вщик      │               │
│  │             │   │             │   │   времени   │               │
│  │ Состояние   │   │ Создает     │   │ Кодирует    │               │
│  │ узла s(t)   │   │ msg из      │   │ признаки Δt │               │
│  │             │   │ событий     │   │             │               │
│  └──────┬──────┘   └──────┬──────┘   └──────┬──────┘               │
│         │                 │                 │                        │
│         └────────────┬────┴────────────────┘                        │
│                      │                                               │
│                      ▼                                               │
│              ┌───────────────┐                                      │
│              │    Модуль     │                                      │
│              │   эмбеддинга  │                                      │
│              │               │                                      │
│              │ Темпоральная  │                                      │
│              │ GNN агрегация │                                      │
│              └───────┬───────┘                                      │
│                      │                                               │
│                      ▼                                               │
│              ┌───────────────┐                                      │
│              │    Головы     │                                      │
│              │  предсказания │                                      │
│              │               │                                      │
│              │ • Связи       │                                      │
│              │ • Классы      │                                      │
│              │ • Цена        │                                      │
│              └───────────────┘                                      │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### Типы узлов в финансовых графах

```
Категории узлов:
├── Активы
│   ├── BTCUSDT (Биткоин перпетуал)
│   ├── ETHUSDT (Эфириум перпетуал)
│   └── ... (другие торговые пары)
│
├── Рыночные события
│   ├── Крупные сделки (активность китов)
│   ├── Ликвидации
│   └── Изменения ставки финансирования
│
├── Состояния стакана
│   ├── Уровни глубины бидов
│   └── Уровни глубины асков
│
└── Внешние сигналы
    ├── Индикаторы настроений
    └── Ончейн метрики
```

### Типы рёбер

```
Категории рёбер:
├── Ценовая корреляция
│   └── Вес: Скользящий коэффициент корреляции
│
├── Поток ордеров
│   └── Вес: Объем торгов между активами
│
├── Связи ликвидности
│   └── Вес: Общие маркетмейкеры / глубина
│
├── Причинные связи
│   └── Вес: Сила причинности по Грейнджеру
│
└── Временная близость
    └── Вес: 1 / (1 + Δt)
```

## Модуль памяти

Модуль памяти — это сердце TGN, позволяющее сети сохранять состояние между событиями.

### Структура состояния памяти

Для каждого узла $i$ память содержит:

```
Состояние памяти s_i(t):
├── Сырой вектор памяти: [d_memory измерений]
│   └── Обученное представление истории взаимодействий
│
├── Время последнего обновления: t_last
│   └── Когда этот узел последний раз участвовал в событии
│
├── Счётчик взаимодействий: n_interactions
│   └── Количество событий с участием этого узла
│
└── Фактор затухания: λ_i
    └── Как быстро старая информация угасает
```

### Механизмы обновления памяти

#### 1. Обновление на основе GRU (по умолчанию)

$$s_i(t) = \text{GRU}(s_i(t^-), m_i(t))$$

Где:
- $z = \sigma(W_z [s_i(t^-), m_i(t)])$ (вентиль обновления)
- $r = \sigma(W_r [s_i(t^-), m_i(t)])$ (вентиль сброса)
- $\tilde{s} = \tanh(W [r \odot s_i(t^-), m_i(t)])$ (кандидат)
- $s_i(t) = (1-z) \odot s_i(t^-) + z \odot \tilde{s}$ (новое состояние)

#### 2. Обновление на основе внимания

$$s_i(t) = s_i(t^-) + \text{Attn}(s_i(t^-), [m_1, ..., m_k])$$

#### 3. Обновление на основе затухания

$$s_i(t) = \exp(-\lambda \cdot \Delta t) \cdot s_i(t^-) + (1 - \exp(-\lambda \cdot \Delta t)) \cdot m_i(t)$$

### Устаревание памяти

```
┌─────────────────────────────────────────────────────────────────┐
│                    Проблема устаревания памяти                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Время ──────────────────────────────────────────────────────→   │
│                                                                  │
│  Узел A:  ●───────────────────────────────────────●──────→      │
│           ↑                                       ↑              │
│        Активен                                 Активен           │
│        Свежая память                           Устаревшая!       │
│                                                                  │
│  Решение: Применять временное затухание к устаревшей памяти     │
│                                                                  │
│  s_effective(t) = exp(-λ · (t - t_last)) · s(t_last)            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## Функция сообщений

Функция сообщений вычисляет информацию для передачи между узлами во время события.

### Типы сообщений

#### 1. Сообщение источника (от инициатора)

$$m_{src}(t) = \text{MLP}([s_u(t^-) \| s_v(t^-) \| e(t) \| \phi(t)])$$

#### 2. Сообщение назначения (к получателю)

$$m_{dst}(t) = \text{MLP}([s_v(t^-) \| s_u(t^-) \| e(t) \| \phi(t)])$$

Где:
- $s_u, s_v$ — состояния памяти источника и назначения
- $e(t)$ — признаки ребра (информация о сделке)
- $\phi(t)$ — кодирование времени

### Агрегация сообщений

Когда несколько событий затрагивают один узел в батче:

```
Опции агрегации:
├── Самое последнее: Использовать только последнее сообщение
├── Среднее: Усреднить все сообщения
├── Сумма: Суммировать все сообщения
├── Внимание: Взвешенная комбинация
└── LSTM: Последовательная обработка по времени
```

### Признаки финансовых сообщений

```
Признаки рёбер для крипто-трейдинга:
├── Информация о сделке
│   ├── price: Цена исполнения
│   ├── size: Объем сделки
│   ├── side: Покупка/Продажа
│   └── value: Стоимость в USD
│
├── Контекст стакана
│   ├── bid_depth_ratio: Соотношение объемов Bid vs Ask
│   ├── spread: Текущий спред
│   └── impact: Ценовое влияние сделки
│
├── Рыночный контекст
│   ├── volatility: Недавняя волатильность
│   ├── trend: Недавний ценовой тренд
│   └── volume_percentile: Объем vs среднее
│
└── Временной контекст
    ├── time_since_last: Δt с последней сделки
    ├── trade_rate: Недавняя частота сделок
    └── time_of_day: Циклическое кодирование
```

## Кодирование времени

Кодирование времени критически важно для захвата временных паттернов в финансовых данных.

### Функциональное кодирование времени

Использование обучаемых периодических функций:

$$\phi(t) = \sqrt{\frac{1}{d}}[\cos(\omega_1 t + \phi_1), \sin(\omega_1 t + \phi_1), ..., \cos(\omega_d t + \phi_d), \sin(\omega_d t + \phi_d)]$$

### Кодирование Time2Vec

Обучаемый подход, захватывающий как периодические, так и непериодические паттерны:

$$\text{Time2Vec}(t)[i] = \begin{cases} \omega_i t + \phi_i & \text{если } i = 0 \\ \sin(\omega_i t + \phi_i) & \text{если } 1 \leq i \leq k \end{cases}$$

### Многомасштабное кодирование времени

```
┌─────────────────────────────────────────────────────────────────┐
│              Многомасштабное кодирование времени                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Масштаб 1: Миллисекунды (Микроструктура рынка)                 │
│  └── Захватывает: Приход ордеров, HFT паттерны                  │
│                                                                  │
│  Масштаб 2: Секунды (Поток сделок)                              │
│  └── Захватывает: Кластеризация сделок, моментум                │
│                                                                  │
│  Масштаб 3: Минуты (Краткосрочные тренды)                       │
│  └── Захватывает: Внутридневные паттерны, реакция на новости    │
│                                                                  │
│  Масштаб 4: Часы (Паттерны сессий)                              │
│  └── Захватывает: Открытие/закрытие рынка, время фандинга       │
│                                                                  │
│  Масштаб 5: Дни (Макро тренды)                                  │
│  └── Захватывает: Недельные циклы, эффекты выходных             │
│                                                                  │
│  Комбинация: φ(t) = Concat([φ_1(t), φ_2(t), ..., φ_5(t)])       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Относительное vs Абсолютное время

Для финансовых рынков мы обычно кодируем:

1. **Относительное время (Δt)**: Время с последнего взаимодействия (наиболее важно)
2. **Абсолютные временные признаки**: Час дня, день недели (для периодичности)
3. **Событийное время**: Время с последнего фандинга, с последней крупной сделки

## Подход к обучению

### Самообучение

TGN использует предсказание темпоральных связей как задачу самообучения:

$$\mathcal{L} = -\sum_{(u,v,t) \in \mathcal{E}^+} \log p(u, v, t) - \sum_{(u,v',t) \in \mathcal{E}^-} \log(1 - p(u, v', t))$$

### Стратегии обучения

#### 1. Пакетное обучение с временным упорядочиванием

```
Обработка обучающего батча:
1. Сортировка событий по времени
2. Разбиение на временные батчи
3. Для каждого батча:
   a. Вычисление сообщений для всех событий
   b. Агрегация сообщений по узлам
   c. Обновление памяти
   d. Вычисление эмбеддингов
   e. Расчёт функции потерь
   f. Обратное распространение (не через обновление памяти)
```

#### 2. Обучение модуля памяти

Память обучается сквозным образом, но обновляется без градиента:

```python
# Псевдокод для обучения памяти
for batch in temporal_batches:
    # Прямой проход
    embeddings = model.compute_embeddings(batch, memory)
    loss = compute_loss(embeddings, labels)

    # Обратный проход (градиенты только через эмбеддинг)
    loss.backward()
    optimizer.step()

    # Обновление памяти (без градиента)
    with torch.no_grad():
        memory = model.update_memory(batch, memory)
```

### Стратегии негативного сэмплирования

```
Негативное сэмплирование для предсказания связей:
├── Случайное: Случайные пары узлов (базовый)
├── Историческое: Прошлые взаимодействия (сложнее)
├── Темпоральное: События из разных временных точек
└── Индуктивное: Узлы не из обучающего набора
```

## Применение к торговле криптовалютами

### Структура графа рынка Bybit

```
┌─────────────────────────────────────────────────────────────────────────┐
│                  Темпоральный торговый граф Bybit                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│    ┌─────────────────────────────────────────────────────────────┐      │
│    │                       Слой активов                           │      │
│    │                                                              │      │
│    │  BTCUSDT ←─────────────→ ETHUSDT ←──────────→ SOLUSDT       │      │
│    │     ↑                       ↑                    ↑           │      │
│    │     │ фандинг              │ корреляция         │ объем      │      │
│    │     ↓                       ↓                    ↓           │      │
│    └─────────────────────────────────────────────────────────────┘      │
│                                                                          │
│    ┌─────────────────────────────────────────────────────────────┐      │
│    │                       Слой событий                           │      │
│    │                                                              │      │
│    │  Сделка ──→ Актив   (Создаёт темпоральное ребро)            │      │
│    │  Ликвидация ──→ Актив (Влияет на все коррелированные)       │      │
│    │  Ставка фандинга ──→ Актив (8-часовой цикл)                 │      │
│    │                                                              │      │
│    └─────────────────────────────────────────────────────────────┘      │
│                                                                          │
│    События текут непрерывно, обновляя память узлов и рёбра              │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### Обработка событий в реальном времени

```
┌────────────────────────────────────────────────────────────────────┐
│                 Поток событий Bybit WebSocket                       │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  WebSocket поток:                                                   │
│  ├── Поток сделок    → Создание событий сделок                    │
│  ├── Стакан заявок   → Обновление признаков глубины               │
│  ├── Тикер           → Обновление признаков цены                  │
│  └── Ликвидации      → Создание событий ликвидации                │
│                                                                     │
│  Обработка TGN:                                                     │
│  ├── Буферизация событий во временном окне (напр., 100мс)         │
│  ├── Сортировка по времени                                         │
│  ├── Пакетная обработка через TGN                                 │
│  ├── Обновление памяти узлов                                       │
│  ├── Генерация эмбеддингов                                         │
│  └── Производство торговых сигналов                               │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
```

### Инженерия признаков

| Категория признаков | Признаки | Триггер обновления |
|-------------------|----------|---------------------|
| Признаки сделки | цена, размер, сторона, импакт | Каждая сделка |
| Стакан | спред, дисбаланс, глубина | Обновление стакана |
| OHLCV | open, high, low, close, volume | Закрытие свечи |
| Фандинг | ставка, обратный отсчёт, прогноз | Каждые 8 часов |
| Открытый интерес | OI, изменение OI, long/short | Изменение позиций |
| Темпоральные | время_с_сделки, частота_сделок | Каждое событие |

### Конвейер генерации сигналов

```
┌────────────────────────────────────────────────────────────────────────┐
│                 Конвейер торговых сигналов TGN                          │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. Приём событий                                                       │
│     └── Получение событий сделок/стакана/ликвидаций от Bybit           │
│                                                                         │
│  2. Вычисление сообщений                                                │
│     └── Для каждого события вычислить исходящее и входящее сообщение   │
│                                                                         │
│  3. Обновление памяти                                                   │
│     └── Обновление состояний памяти для затронутых узлов               │
│                                                                         │
│  4. Генерация эмбеддингов                                               │
│     └── Вычисление темпоральных эмбеддингов с обновлённой памятью      │
│                                                                         │
│  5. Головы предсказаний                                                 │
│     ├── Направление: P(цена_вверх | эмбеддинг)                         │
│     ├── Величина: E[доходность | эмбеддинг]                            │
│     ├── Волатильность: E[волатильность | эмбеддинг]                    │
│     └── Корреляция: P(актив_i движется с актив_j)                      │
│                                                                         │
│  6. Агрегация сигналов                                                  │
│     └── Объединение предсказаний в действенные сигналы                 │
│                                                                         │
│  7. Размер позиции                                                      │
│     └── Критерий Келли с взвешиванием по уверенности                   │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Пример торговой стратегии

```rust
// Псевдокод для торговой стратегии на основе TGN

fn process_event(event: MarketEvent, tgn: &mut TemporalGNN) -> Option<Signal> {
    // Обновление памяти для узлов источника и назначения
    let messages = tgn.compute_messages(&event);
    tgn.update_memories(messages);

    // Получение текущих эмбеддингов
    let embeddings = tgn.get_embeddings(&[event.symbol]);

    // Предсказание направления и уверенности
    let (prob_up, prob_down, confidence) = tgn.predict_direction(&embeddings);

    // Генерация сигнала при достаточной уверенности
    if confidence > 0.7 {
        if prob_up > 0.6 {
            Some(Signal::Long {
                symbol: event.symbol,
                strength: prob_up,
                confidence
            })
        } else if prob_down > 0.6 {
            Some(Signal::Short {
                symbol: event.symbol,
                strength: prob_down,
                confidence
            })
        } else {
            None
        }
    } else {
        None
    }
}
```

## Стратегия реализации

### Архитектура модулей

```
346_temporal_gnn_trading/
├── src/
│   ├── lib.rs              # Корень библиотеки
│   ├── memory/
│   │   ├── mod.rs          # Модуль памяти
│   │   ├── state.rs        # Управление состоянием памяти
│   │   └── updater.rs      # Механизмы обновления памяти
│   ├── message/
│   │   ├── mod.rs          # Модуль сообщений
│   │   ├── function.rs     # Вычисление сообщений
│   │   └── aggregator.rs   # Агрегация сообщений
│   ├── temporal/
│   │   ├── mod.rs          # Темпоральный модуль
│   │   ├── encoder.rs      # Кодирование времени
│   │   └── attention.rs    # Темпоральное внимание
│   ├── embedding/
│   │   ├── mod.rs          # Модуль эмбеддингов
│   │   └── graph_conv.rs   # Графовая свёртка
│   ├── data/
│   │   ├── mod.rs          # Модуль данных
│   │   ├── bybit.rs        # API клиент Bybit
│   │   ├── events.rs       # Определения событий
│   │   └── features.rs     # Инженерия признаков
│   ├── strategy/
│   │   ├── mod.rs          # Модуль стратегии
│   │   ├── signals.rs      # Генерация сигналов
│   │   └── execution.rs    # Исполнение ордеров
│   └── utils/
│       ├── mod.rs          # Утилиты
│       └── metrics.rs      # Метрики производительности
├── examples/
│   ├── basic_tgn.rs        # Базовый пример TGN
│   ├── live_trading.rs     # Демо живой торговли
│   └── backtest.rs         # Пример бэктестинга
└── tests/
    └── integration.rs      # Интеграционные тесты
```

### Ключевые принципы проектирования

1. **Событийно-управляемый**: Обработка событий по мере поступления, а не фиксированными батчами
2. **Эффективность памяти**: Инкрементальные обновления, а не полное перевычисление
3. **Низкая задержка**: Оптимизация для генерации сигналов в реальном времени
4. **Типобезопасность**: Использование системы типов Rust для корректности
5. **Модульность**: Независимые компоненты для простого тестирования и расширения

## Управление рисками

### Темпорально-осведомлённые метрики риска

```
┌────────────────────────────────────────────────────────────────┐
│                 Темпоральная оценка риска                       │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Уверенность на основе памяти:                                  │
│  └── Выше уверенность, когда память свежая                     │
│  └── Ниже уверенность, когда много узлов с устаревшей памятью  │
│                                                                 │
│  Риск частоты событий:                                          │
│  └── Высокая частота → Выше риск волатильности                 │
│  └── Низкая частота → Возможен риск ликвидности                │
│                                                                 │
│  Стабильность корреляций:                                       │
│  └── Отслеживание скорости изменения рёбер корреляции          │
│  └── Высокая нестабильность → Уменьшить размеры позиций        │
│                                                                 │
│  Расхождение памяти:                                            │
│  └── Большая разница между свежей и старой памятью             │
│  └── Указывает на смену режима → Повышенная осторожность       │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
```

### Лимиты позиций

```
Ограничения риска:
├── Макс. размер позиции: 5% от портфеля
├── Макс. коррелированная экспозиция: 15%
├── Макс. устаревание памяти: 1 час
├── Мин. порог уверенности: 0.6
├── Триггер макс. просадки: 10%
└── Лимит плеча: 3x
```

### Автоматические выключатели

1. **Устаревание памяти**: Пауза при слишком старой памяти критических узлов
2. **Шторм событий**: Снижение активности при аномальной частоте событий
3. **Разрыв корреляций**: Выход при быстром изменении структуры рёбер
4. **Неуверенность модели**: Остановка при падении уверенности предсказаний

## Метрики производительности

### Метрики модели

| Метрика | Описание | Цель |
|---------|----------|------|
| AUC предсказания связей | Предсказание будущих взаимодействий | > 0.80 |
| Точность направления | Предсказание направления цены | > 56% |
| Темпоральная точность | Точность по времени предсказаний | > 0.70 |
| Коэффициент Шарпа | Доходность с учётом риска | > 2.0 |
| Макс. просадка | Наибольшее падение от пика | < 12% |
| Коэффициент Кальмара | Доходность / Макс. просадка | > 1.5 |

### Требования к задержке

```
┌─────────────────────────────────────────────────────────┐
│                   Бюджет задержки                        │
├─────────────────────────────────────────────────────────┤
│ Приём события:          < 5мс                            │
│ Вычисление сообщений:   < 20мс                           │
│ Обновление памяти:      < 10мс                           │
│ Генерация эмбеддингов:  < 50мс                           │
│ Производство сигнала:   < 15мс                           │
│ Отправка ордера:        < 30мс                           │
├─────────────────────────────────────────────────────────┤
│ Полный цикл:            < 130мс                          │
└─────────────────────────────────────────────────────────┘
```

### Эффективность памяти

```
Требования памяти на узел:
├── Состояние памяти: 128 float × 4 байта = 512 байт
├── Время последнего обновления: 8 байт
├── Счётчик взаимодействий: 4 байта
├── Кэш признаков: 64 float × 4 байта = 256 байт
└── Всего на узел: ~800 байт

Для 1000 активов: ~800 КБ базовой памяти
Плюс буфер истории событий: ~10 МБ
Общее требование системы: < 50 МБ
```

## Литература

1. Rossi, E., et al. (2020). "Temporal Graph Networks for Deep Learning on Dynamic Graphs." *ICML Workshop on Graph Representation Learning*. https://arxiv.org/abs/2006.10637

2. Xu, D., et al. (2020). "Inductive Representation Learning on Temporal Graphs." *ICLR*

3. Kazemi, S.M., et al. (2020). "Representation Learning for Dynamic Graphs: A Survey." *JMLR*

4. Kumar, S., et al. (2019). "Predicting Dynamic Embedding Trajectory in Temporal Interaction Networks." *KDD*

5. Trivedi, R., et al. (2019). "DyRep: Learning Representations over Dynamic Graphs." *ICLR*

6. Wang, Y., et al. (2021). "Inductive Representation Learning in Temporal Networks via Causal Anonymous Walks." *ICLR*

7. Poursafaei, F., et al. (2022). "Towards Better Evaluation for Dynamic Link Prediction." *NeurIPS*

---

## Следующие шаги

- [Простое объяснение](readme.simple.ru.md) - Версия для начинающих
- [English Version](README.md) - Английская версия
- [Примеры](examples/) - Рабочий код на Rust

---

*Глава 346 книги "Машинное обучение для трейдинга"*

"""
Backtesting Module for RAG Trading Signals

This module provides a framework for backtesting trading strategies
based on RAG-generated signals.
"""

import numpy as np
import pandas as pd
from typing import List, Dict, Optional, Tuple, Any
from dataclasses import dataclass, field
from datetime import datetime

from .signals import RAGTradingSignalGenerator, SignalDirection, TradingSignal


@dataclass
class Trade:
    """Record of a single trade."""
    ticker: str
    entry_date: datetime
    entry_price: float
    exit_date: Optional[datetime] = None
    exit_price: Optional[float] = None
    direction: SignalDirection = SignalDirection.LONG
    shares: float = 0
    signal_confidence: float = 0.0
    pnl: float = 0.0
    return_pct: float = 0.0

    @property
    def is_closed(self) -> bool:
        return self.exit_date is not None


@dataclass
class BacktestResult:
    """
    Results from backtesting a RAG-based strategy.

    Attributes:
        total_return: Total portfolio return (e.g., 0.15 = 15%)
        sharpe_ratio: Annualized Sharpe ratio
        max_drawdown: Maximum drawdown (negative value)
        win_rate: Percentage of winning trades
        total_trades: Total number of completed trades
        avg_trade_return: Average return per trade
        trades: List of all trades
        equity_curve: Portfolio value over time
        metadata: Additional metrics
    """
    total_return: float
    sharpe_ratio: float
    max_drawdown: float
    win_rate: float
    total_trades: int
    avg_trade_return: float
    trades: List[Trade] = field(default_factory=list)
    equity_curve: List[float] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def summary(self) -> str:
        """Generate a summary string of backtest results."""
        return f"""
Backtest Results Summary
========================
Total Return:     {self.total_return:>10.2%}
Sharpe Ratio:     {self.sharpe_ratio:>10.2f}
Max Drawdown:     {self.max_drawdown:>10.2%}
Win Rate:         {self.win_rate:>10.2%}
Total Trades:     {self.total_trades:>10d}
Avg Trade Return: {self.avg_trade_return:>10.2%}
"""

    def to_dict(self) -> Dict[str, Any]:
        """Convert results to dictionary."""
        return {
            "total_return": self.total_return,
            "sharpe_ratio": self.sharpe_ratio,
            "max_drawdown": self.max_drawdown,
            "win_rate": self.win_rate,
            "total_trades": self.total_trades,
            "avg_trade_return": self.avg_trade_return,
            "metadata": self.metadata
        }


class RAGBacktester:
    """
    Backtest RAG-based trading strategies.

    Simulates trading based on signals generated by a RAGTradingSignalGenerator.
    Supports both long and short positions with configurable position sizing.

    Examples:
        >>> backtester = RAGBacktester(signal_generator, initial_capital=100000)
        >>> results = backtester.backtest(
        ...     ticker="TSLA",
        ...     price_data=price_df,
        ...     signal_dates=dates
        ... )
        >>> print(results.summary())
    """

    def __init__(
        self,
        signal_generator: RAGTradingSignalGenerator,
        initial_capital: float = 100000.0,
        position_size: float = 0.95,
        transaction_cost: float = 0.001,
        allow_short: bool = False
    ):
        """
        Initialize the backtester.

        Args:
            signal_generator: RAG signal generator instance
            initial_capital: Starting capital
            position_size: Fraction of capital to use per trade (0-1)
            transaction_cost: Transaction cost as fraction of trade value
            allow_short: Whether to allow short positions
        """
        self.signal_generator = signal_generator
        self.initial_capital = initial_capital
        self.position_size = position_size
        self.transaction_cost = transaction_cost
        self.allow_short = allow_short

    def backtest(
        self,
        ticker: str,
        price_data: pd.DataFrame,
        signal_dates: Optional[List[datetime]] = None,
        signal_frequency: str = "weekly"
    ) -> BacktestResult:
        """
        Backtest a RAG-based strategy on historical data.

        Args:
            ticker: Stock ticker symbol
            price_data: DataFrame with OHLCV data (DatetimeIndex)
            signal_dates: Specific dates to generate signals
            signal_frequency: Frequency for signal generation if dates not provided
                            ("daily", "weekly", "monthly")

        Returns:
            BacktestResult with performance metrics
        """
        if price_data.empty:
            return self._empty_result()

        # Ensure price_data has lowercase columns
        price_data.columns = [c.lower() for c in price_data.columns]

        # Generate signal dates if not provided
        if signal_dates is None:
            signal_dates = self._generate_signal_dates(
                price_data.index, signal_frequency
            )

        # Initialize tracking variables
        capital = self.initial_capital
        position = 0  # Number of shares held
        position_direction = SignalDirection.NEUTRAL
        entry_price = 0.0
        entry_date = None
        trades: List[Trade] = []
        equity_curve = [capital]

        for date in signal_dates:
            if date not in price_data.index:
                continue

            price = price_data.loc[date, 'close']

            # Generate signal for this date
            signal = self.signal_generator.generate_signal(ticker)

            # Calculate current equity
            current_equity = capital
            if position != 0:
                if position_direction == SignalDirection.LONG:
                    current_equity += position * price
                else:  # SHORT
                    current_equity += position * (2 * entry_price - price)

            # Trading logic
            if signal.direction == SignalDirection.LONG and signal.confidence > 0.5:
                # Close any short position first
                if position < 0 and position_direction == SignalDirection.SHORT:
                    trade = self._close_position(
                        ticker, entry_date, entry_price, date, price,
                        position, position_direction, signal.confidence
                    )
                    capital += trade.pnl
                    trades.append(trade)
                    position = 0

                # Open long position if not already long
                if position == 0:
                    shares_to_buy = int(
                        (capital * self.position_size) / price
                    )
                    if shares_to_buy > 0:
                        cost = shares_to_buy * price * (1 + self.transaction_cost)
                        capital -= cost
                        position = shares_to_buy
                        position_direction = SignalDirection.LONG
                        entry_price = price
                        entry_date = date

            elif signal.direction == SignalDirection.SHORT and signal.confidence > 0.5:
                # Close any long position first
                if position > 0 and position_direction == SignalDirection.LONG:
                    trade = self._close_position(
                        ticker, entry_date, entry_price, date, price,
                        position, position_direction, signal.confidence
                    )
                    capital += trade.pnl
                    trades.append(trade)
                    position = 0

                # Open short position if allowed and not already short
                if self.allow_short and position == 0:
                    shares_to_short = int(
                        (capital * self.position_size) / price
                    )
                    if shares_to_short > 0:
                        position = -shares_to_short
                        position_direction = SignalDirection.SHORT
                        entry_price = price
                        entry_date = date

            elif signal.direction == SignalDirection.NEUTRAL or signal.confidence < 0.3:
                # Close position on neutral/low confidence signal
                if position != 0:
                    trade = self._close_position(
                        ticker, entry_date, entry_price, date, price,
                        abs(position), position_direction, signal.confidence
                    )
                    capital += trade.pnl
                    trades.append(trade)
                    position = 0

            # Update equity curve
            current_equity = capital
            if position != 0:
                if position_direction == SignalDirection.LONG:
                    current_equity += position * price
                else:  # SHORT
                    current_equity += abs(position) * (2 * entry_price - price)
            equity_curve.append(current_equity)

        # Close any remaining position at the end
        if position != 0 and len(price_data) > 0:
            final_price = price_data.iloc[-1]['close']
            final_date = price_data.index[-1]
            trade = self._close_position(
                ticker, entry_date, entry_price, final_date, final_price,
                abs(position), position_direction, 0.5
            )
            capital += trade.pnl
            trades.append(trade)

        # Calculate metrics
        return self._calculate_metrics(trades, equity_curve)

    def _close_position(
        self,
        ticker: str,
        entry_date: datetime,
        entry_price: float,
        exit_date: datetime,
        exit_price: float,
        shares: float,
        direction: SignalDirection,
        confidence: float
    ) -> Trade:
        """Close a position and record the trade."""
        if direction == SignalDirection.LONG:
            gross_pnl = shares * (exit_price - entry_price)
        else:  # SHORT
            gross_pnl = shares * (entry_price - exit_price)

        transaction_costs = (
            shares * entry_price * self.transaction_cost +
            shares * exit_price * self.transaction_cost
        )
        net_pnl = gross_pnl - transaction_costs
        return_pct = net_pnl / (shares * entry_price) if entry_price > 0 else 0

        return Trade(
            ticker=ticker,
            entry_date=entry_date,
            entry_price=entry_price,
            exit_date=exit_date,
            exit_price=exit_price,
            direction=direction,
            shares=shares,
            signal_confidence=confidence,
            pnl=net_pnl,
            return_pct=return_pct
        )

    def _generate_signal_dates(
        self,
        index: pd.DatetimeIndex,
        frequency: str
    ) -> List[datetime]:
        """Generate signal dates based on frequency."""
        if frequency == "daily":
            return list(index)
        elif frequency == "weekly":
            return list(index[::5])  # Every 5 trading days
        elif frequency == "monthly":
            return list(index[::21])  # Every 21 trading days
        else:
            return list(index)

    def _calculate_metrics(
        self,
        trades: List[Trade],
        equity_curve: List[float]
    ) -> BacktestResult:
        """Calculate performance metrics from trades and equity curve."""
        if not trades:
            return self._empty_result()

        # Total return
        final_equity = equity_curve[-1] if equity_curve else self.initial_capital
        total_return = (final_equity - self.initial_capital) / self.initial_capital

        # Calculate returns from equity curve
        equity_series = pd.Series(equity_curve)
        returns = equity_series.pct_change().dropna()

        # Sharpe ratio (annualized)
        if len(returns) > 1 and returns.std() > 0:
            sharpe_ratio = returns.mean() / returns.std() * np.sqrt(252)
        else:
            sharpe_ratio = 0.0

        # Maximum drawdown
        rolling_max = equity_series.cummax()
        drawdown = (equity_series - rolling_max) / rolling_max
        max_drawdown = float(drawdown.min())

        # Win rate
        closed_trades = [t for t in trades if t.is_closed]
        winning_trades = sum(1 for t in closed_trades if t.pnl > 0)
        win_rate = winning_trades / len(closed_trades) if closed_trades else 0.0

        # Average trade return
        trade_returns = [t.return_pct for t in closed_trades]
        avg_trade_return = np.mean(trade_returns) if trade_returns else 0.0

        return BacktestResult(
            total_return=total_return,
            sharpe_ratio=sharpe_ratio,
            max_drawdown=max_drawdown,
            win_rate=win_rate,
            total_trades=len(closed_trades),
            avg_trade_return=avg_trade_return,
            trades=trades,
            equity_curve=equity_curve,
            metadata={
                "initial_capital": self.initial_capital,
                "final_equity": final_equity,
                "winning_trades": winning_trades,
                "losing_trades": len(closed_trades) - winning_trades
            }
        )

    def _empty_result(self) -> BacktestResult:
        """Return empty result when no trades occur."""
        return BacktestResult(
            total_return=0.0,
            sharpe_ratio=0.0,
            max_drawdown=0.0,
            win_rate=0.0,
            total_trades=0,
            avg_trade_return=0.0,
            trades=[],
            equity_curve=[self.initial_capital],
            metadata={"error": "No trades executed"}
        )


def run_backtest_comparison(
    signal_generator: RAGTradingSignalGenerator,
    price_data: pd.DataFrame,
    ticker: str,
    frequencies: List[str] = None
) -> Dict[str, BacktestResult]:
    """
    Run backtests with different signal frequencies for comparison.

    Args:
        signal_generator: RAG signal generator
        price_data: OHLCV price data
        ticker: Stock ticker
        frequencies: List of frequencies to test

    Returns:
        Dict mapping frequency to backtest results
    """
    if frequencies is None:
        frequencies = ["daily", "weekly", "monthly"]

    results = {}
    backtester = RAGBacktester(signal_generator)

    for freq in frequencies:
        results[freq] = backtester.backtest(
            ticker=ticker,
            price_data=price_data,
            signal_frequency=freq
        )

    return results


if __name__ == "__main__":
    print("RAG Backtester Demo")
    print("=" * 50)

    # Generate synthetic price data for demo
    np.random.seed(42)
    dates = pd.date_range(start="2024-01-01", periods=252, freq="B")
    returns = np.random.randn(len(dates)) * 0.02
    close_prices = 100 * (1 + returns).cumprod()

    price_data = pd.DataFrame({
        "open": close_prices * (1 + np.random.randn(len(dates)) * 0.005),
        "high": close_prices * (1 + abs(np.random.randn(len(dates)) * 0.01)),
        "low": close_prices * (1 - abs(np.random.randn(len(dates)) * 0.01)),
        "close": close_prices,
        "volume": np.random.randint(1e6, 1e8, len(dates))
    }, index=dates)

    print(f"\nPrice data: {len(price_data)} days")
    print(f"Start: ${price_data['close'].iloc[0]:.2f}")
    print(f"End: ${price_data['close'].iloc[-1]:.2f}")
    print(f"Buy & Hold Return: {(price_data['close'].iloc[-1] / price_data['close'].iloc[0] - 1):.2%}")

    # Create a simple mock signal generator for demo
    from .retriever import Document, SimpleRetriever
    from .signals import RAGTradingSignalGenerator

    # Add some sample documents
    retriever = SimpleRetriever()
    retriever.add_documents([
        Document.create(
            text="Stock shows strong bullish momentum with increasing volume. "
                 "Analysts upgrade to buy rating.",
            ticker="DEMO",
            source="Demo",
            doc_type="news"
        )
    ])

    generator = RAGTradingSignalGenerator(retriever)
    backtester = RAGBacktester(generator, initial_capital=100000)

    # Run backtest
    print("\nRunning backtest...")
    result = backtester.backtest(
        ticker="DEMO",
        price_data=price_data,
        signal_frequency="weekly"
    )

    print(result.summary())

# Глава 65: Retrieval-Augmented Generation (RAG) для Трейдинга

Эта глава исследует **Retrieval-Augmented Generation (RAG)** — мощную технологию, которая объединяет большие языковые модели с внешним поиском знаний для улучшения торговых решений. RAG позволяет трейдерам использовать данные финансовых рынков в реальном времени, новости, исследовательские отчёты и историческую информацию о рынке для генерации контекстно-релевантных торговых сигналов и анализа.

<p align="center">
<img src="https://i.imgur.com/RAGTrade.png" width="70%">
</p>

## Содержание

1. [Введение в RAG для трейдинга](#введение-в-rag-для-трейдинга)
    * [Что такое RAG?](#что-такое-rag)
    * [Почему RAG для трейдинга?](#почему-rag-для-трейдинга)
    * [RAG против традиционного NLP](#rag-против-традиционного-nlp)
2. [Архитектура RAG](#архитектура-rag)
    * [Основные компоненты](#основные-компоненты)
    * [Конвейер обработки документов](#конвейер-обработки-документов)
    * [Векторные хранилища и эмбеддинги](#векторные-хранилища-и-эмбеддинги)
3. [Торговые применения](#торговые-применения)
    * [Анализ новостей в реальном времени](#анализ-новостей-в-реальном-времени)
    * [Анализ отчётов SEC](#анализ-отчётов-sec)
    * [Аналитика звонков с инвесторами](#аналитика-звонков-с-инвесторами)
    * [Синтез рыночных исследований](#синтез-рыночных-исследований)
4. [Практические примеры](#практические-примеры)
    * [01: Система поиска документов](#01-система-поиска-документов)
    * [02: Генерация торговых сигналов](#02-генерация-торговых-сигналов)
    * [03: Анализ портфеля с RAG](#03-анализ-портфеля-с-rag)
    * [04: Бэктестинг RAG-сигналов](#04-бэктестинг-rag-сигналов)
5. [Реализация на Rust](#реализация-на-rust)
6. [Реализация на Python](#реализация-на-python)
7. [Лучшие практики](#лучшие-практики)
8. [Ресурсы](#ресурсы)

## Введение в RAG для трейдинга

### Что такое RAG?

Retrieval-Augmented Generation (RAG) — это гибридный подход, который объединяет генеративные возможности больших языковых моделей (LLM) с системами информационного поиска. Вместо того чтобы полагаться исключительно на параметрические знания модели, RAG извлекает релевантные документы из внешней базы знаний и использует их как контекст для генерации.

```
РАБОЧИЙ ПРОЦЕСС RAG ДЛЯ ТРЕЙДИНГА:
┌──────────────────────────────────────────────────────────────────────────────┐
│                                                                               │
│  Запрос пользователя: "Какие последние новости о Tesla и как они могут      │
│                        повлиять на цену акций завтра?"                       │
│                                                                               │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │                    Шаг 1: ПОИСК (RETRIEVAL)                             │  │
│  │  ┌─────────────────────┐     ┌─────────────────────────────────────┐   │  │
│  │  │  Эмбеддинг запроса  │ ──▶ │    Поиск в векторной БД              │   │  │
│  │  │  "Tesla новости..." │     │  • Свежие новостные статьи           │   │  │
│  │  └─────────────────────┘     │  • Отчёты SEC                        │   │  │
│  │                              │  • Аналитические отчёты              │   │  │
│  │                              │  • Настроения в соцсетях             │   │  │
│  │                              └─────────────────────────────────────┘   │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                        │                                      │
│                                        ▼                                      │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │                    Шаг 2: ДОПОЛНЕНИЕ (AUGMENTATION)                     │  │
│  │  Найденные документы:                                                   │  │
│  │  • "Поставки Tesla в Q3 превысили ожидания на 15%..."                  │  │
│  │  • "Илон Маск анонсировал новый завод в Техасе..."                     │  │
│  │  • "Аналитик повысил рейтинг TSLA до Buy с целью $300..."              │  │
│  │  + Исходный запрос                                                      │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                        │                                      │
│                                        ▼                                      │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │                    Шаг 3: ГЕНЕРАЦИЯ (GENERATION)                        │  │
│  │  LLM генерирует ответ с найденным контекстом:                          │  │
│  │  "На основе последних событий, у Tesla несколько позитивных факторов:  │  │
│  │   1. Поставки в Q3 превысили ожидания (+15%)                           │  │
│  │   2. Анонс нового завода в Техасе сигнализирует о расширении           │  │
│  │   3. Множественные повышения рейтингов от аналитиков                   │  │
│  │   Сигнал: УМЕРЕННАЯ ПОКУПКА (уверенность: 72%)"                        │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

### Почему RAG для трейдинга?

Традиционные LLM имеют несколько ограничений для торговых приложений:

| Проблема | Традиционный LLM | Решение RAG |
|----------|-----------------|-------------|
| **Устаревание знаний** | Обучен на исторических данных, не знает о недавних событиях | Извлекает актуальную информацию |
| **Галлюцинации** | Может генерировать правдоподобные, но неверные факты | Основывает ответы на найденных документах |
| **Атрибуция источников** | Не может указать источники утверждений | Предоставляет явные ссылки на документы |
| **Специфика домена** | Общие знания могут упускать финансовые нюансы | Извлекает доменно-специфичные документы |
| **Обновляемость** | Требует дорогого переобучения | Просто обновите базу документов |

### RAG против традиционного NLP

```
СРАВНЕНИЕ: RAG vs ДООБУЧЕННЫЙ LLM vs ТРАДИЦИОННЫЙ NLP
═══════════════════════════════════════════════════════════════════════════════

                    Традиционный NLP   Дообученный LLM    RAG
                    ────────────────   ────────────────   ────────────────
Обновление знаний   Переобучение       Переобучение       Только обновление БД
                    (дни/недели)       (часы/дни)         (секунды)

Реальное время      Невозможно         Невозможно         ✅ Поддерживается

Стоимость           $$$$               $$$                $
обновления

Объяснимость        Низкая             Средняя            Высокая (цитаты)

Точность на         Средняя            Хорошая            Очень хорошая
свежих событиях

Риск                Н/П                Высокий            Низкий
галлюцинаций

Масштабируемость    Фиксированная      Фиксированная      Масштабируется с БД

Лучший случай       Статические задачи Адаптация домена   Динамические знания
```

## Архитектура RAG

### Основные компоненты

Система RAG для трейдинга состоит из четырёх основных компонентов:

```
АРХИТЕКТУРА RAG ДЛЯ ТРЕЙДИНГА
┌──────────────────────────────────────────────────────────────────────────────┐
│                                                                               │
│   ┌─────────────────────────────────────────────────────────────────────┐    │
│   │                     СЛОЙ ЗАГРУЗКИ ДОКУМЕНТОВ                         │    │
│   │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌────────────┐  │    │
│   │  │ News APIs   │  │ SEC Edgar   │  │ Исследов.   │  │ Соц.       │  │    │
│   │  │ (Bloomberg, │  │ (10-K, 10-Q,│  │ отчёты      │  │ сети       │  │    │
│   │  │  Reuters)   │  │  8-K, и др.)│  │ (аналитики) │  │ (Twitter)  │  │    │
│   │  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  └─────┬──────┘  │    │
│   └─────────┼────────────────┼────────────────┼───────────────┼─────────┘    │
│             └────────────────┼────────────────┼───────────────┘              │
│                              ▼                ▼                               │
│   ┌─────────────────────────────────────────────────────────────────────┐    │
│   │                     ОБРАБОТКА ДОКУМЕНТОВ                             │    │
│   │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌────────────┐  │    │
│   │  │  Разбиение  │──│   Очистка   │──│  Извлечение │──│ Генерация  │  │    │
│   │  │  (по темам, │  │ (нормализ., │  │  метаданных │  │ эмбеддингов│  │    │
│   │  │   разделам) │  │  дедупликац)│  │ (дата,тикер,│  │ (OpenAI,   │  │    │
│   │  │             │  │             │  │  источник)  │  │  локальные)│  │    │
│   │  └─────────────┘  └─────────────┘  └─────────────┘  └────────────┘  │    │
│   └─────────────────────────────────────────────────────────────────────┘    │
│                                        │                                      │
│                                        ▼                                      │
│   ┌─────────────────────────────────────────────────────────────────────┐    │
│   │                     ВЕКТОРНОЕ ХРАНИЛИЩЕ                              │    │
│   │  ┌─────────────────────────────────────────────────────────────┐    │    │
│   │  │  Эмбеддинги документов (1536-мерные векторы)                 │    │    │
│   │  │  ┌──────────────────────────────────────────────────────┐   │    │    │
│   │  │  │ ID: doc_001 | Тикер: TSLA | Дата: 2024-01-15         │   │    │    │
│   │  │  │ Вектор: [0.021, -0.045, 0.089, ..., 0.012]           │   │    │    │
│   │  │  │ Текст: "Tesla сообщила о поставках Q4: 484,507..."   │   │    │    │
│   │  │  └──────────────────────────────────────────────────────┘   │    │    │
│   │  └─────────────────────────────────────────────────────────────┘    │    │
│   │  Варианты хранения: ChromaDB | Pinecone | Weaviate | FAISS          │    │
│   └─────────────────────────────────────────────────────────────────────┘    │
│                                        │                                      │
│                                        ▼                                      │
│   ┌─────────────────────────────────────────────────────────────────────┐    │
│   │                     ПОИСК И ГЕНЕРАЦИЯ                                │    │
│   │  ┌──────────────────────────┐    ┌──────────────────────────┐       │    │
│   │  │   Семантический поиск    │    │   Генерация LLM          │       │    │
│   │  │  • Эмбеддинг запроса     │───▶│  • Интеграция контекста  │       │    │
│   │  │  • k-NN поиск            │    │  • Торговый анализ       │       │    │
│   │  │  • Ранжирование          │    │  • Генерация сигналов    │       │    │
│   │  │  • Фильтрация (дата,     │    │  • Оценка рисков         │       │    │
│   │  │    тикер, релевантность) │    │  • Цитирование источников│       │    │
│   │  └──────────────────────────┘    └──────────────────────────┘       │    │
│   └─────────────────────────────────────────────────────────────────────┘    │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

### Конвейер обработки документов

Эффективный RAG требует тщательной обработки документов:

```python
# Конвейер обработки документов для финансовых документов
class FinancialDocumentProcessor:
    """
    Обработка финансовых документов для индексации RAG.

    Обрабатывает:
    - Новостные статьи
    - Отчёты SEC (10-K, 10-Q, 8-K)
    - Транскрипты звонков с инвесторами
    - Исследовательские отчёты
    """

    def __init__(self, chunk_size: int = 512, chunk_overlap: int = 50):
        self.chunk_size = chunk_size
        self.chunk_overlap = chunk_overlap

    def process(self, document: str, metadata: dict) -> List[DocumentChunk]:
        """
        Обработка документа в чанки с метаданными.

        Args:
            document: Сырой текст документа
            metadata: Метаданные документа (источник, дата, тикеры)

        Returns:
            Список обработанных чанков документа
        """
        # Шаг 1: Очистка и нормализация
        cleaned = self._clean_text(document)

        # Шаг 2: Извлечение дополнительных метаданных
        entities = self._extract_entities(cleaned)
        metadata["entities"] = entities

        # Шаг 3: Разбиение документа на чанки
        chunks = self._chunk_document(cleaned)

        # Шаг 4: Генерация эмбеддингов
        embeddings = self._generate_embeddings(chunks)

        return [
            DocumentChunk(
                text=chunk,
                embedding=emb,
                metadata={**metadata, "chunk_idx": i}
            )
            for i, (chunk, emb) in enumerate(zip(chunks, embeddings))
        ]
```

### Векторные хранилища и эмбеддинги

Выбор правильной модели эмбеддингов и векторного хранилища критически важен:

| Модель эмбеддингов | Размерность | Лучше всего для | Стоимость |
|-------------------|------------|-----------------|-----------|
| OpenAI text-embedding-3-large | 3072 | Высокая точность | API |
| OpenAI text-embedding-3-small | 1536 | Баланс | API |
| Sentence-BERT | 768 | Приватность, офлайн | Бесплатно |
| FinBERT Embeddings | 768 | Финансовый домен | Бесплатно |

| Хранилище | Масштабируемость | Особенности | Развёртывание |
|-----------|-----------------|-------------|---------------|
| **ChromaDB** | Малая-Средняя | Простая настройка | Локально/Облако |
| **FAISS** | Большая | Высокая производительность | Локально |
| **Pinecone** | Очень большая | Управляемый, быстрый | Облако |
| **Weaviate** | Большая | GraphQL, гибридный поиск | Self-hosted/Облако |
| **Qdrant** | Большая | Быстрый, на Rust | Self-hosted/Облако |

## Торговые применения

### Анализ новостей в реальном времени

RAG позволяет проводить сложный анализ новостей для трейдинга:

```python
# Анализ новостей в реальном времени с RAG
class NewsRAGAnalyzer:
    """
    Анализ новостей в реальном времени для генерации торговых сигналов.
    """

    def analyze_news(self, query: str, tickers: List[str]) -> TradingSignal:
        """
        Анализ новостей и генерация торговых сигналов.

        Пример:
            >>> analyzer = NewsRAGAnalyzer()
            >>> signal = analyzer.analyze_news(
            ...     "Какой рыночный настрой по TSLA сегодня?",
            ...     tickers=["TSLA"]
            ... )
            >>> print(signal)
            TradingSignal(
                ticker="TSLA",
                direction="LONG",
                confidence=0.72,
                reasoning="На основе 3 недавних новостных статей...",
                sources=["Reuters", "Bloomberg", "WSJ"]
            )
        """
        # Поиск релевантных документов
        docs = self.retriever.search(
            query=query,
            filters={"ticker": {"$in": tickers}},
            top_k=10
        )

        # Генерация анализа с помощью LLM
        context = self._format_context(docs)
        prompt = self._build_prompt(query, context)

        response = self.llm.generate(prompt)

        return self._parse_signal(response, docs)
```

### Анализ отчётов SEC

Автоматизированный анализ регуляторных отчётов:

```python
# Пример: Анализ формы 10-K
filing_analysis = rag_analyzer.analyze(
    query="Какие основные факторы риска упомянуты в последнем 10-K Tesla?",
    document_types=["10-K"],
    tickers=["TSLA"]
)

# Результат:
"""
На основе формы 10-K Tesla за 2023 год, основные факторы риска включают:

1. **Риски производственных мощностей** (Раздел 1A, Стр. 15)
   - Зависимость от выпуска Gigafactory
   - Ограничения в цепочке поставок батарей

2. **Регуляторные риски** (Раздел 1A, Стр. 18)
   - Изменения в налоговых льготах для EV
   - Регулирование автономного вождения

3. **Конкурентные риски** (Раздел 1A, Стр. 21)
   - Рост конкуренции со стороны традиционных автопроизводителей
   - Китайские производители EV выходят на рынок США

Источники: [Форма SEC 10-K от 2024-01-29, страницы 15-24]
"""
```

### Аналитика звонков с инвесторами

Извлечение информации из звонков с инвесторами:

```
АНАЛИЗ EARNINGS CALL С ПОМОЩЬЮ RAG
═══════════════════════════════════════════════════════════════════════════════

Запрос: "Какой прогноз Apple дал на следующий квартал?"

Найденный контекст:
┌──────────────────────────────────────────────────────────────────────────────┐
│ [1] Транскрипт Apple Q4 2024 Earnings Call (31 окт. 2024)                   │
│     "На Q1 мы ожидаем выручку между $118-122 млрд, что представляет        │
│      5-8% рост год к году. Сервисы должны продолжить сильную динамику      │
│      с ожидаемым двузначным ростом."                                        │
├──────────────────────────────────────────────────────────────────────────────┤
│ [2] Подготовленные замечания CFO Apple                                      │
│     "Прогноз валовой маржи на Q1: 45-46%, что соответствует                │
│      нашим историческим паттернам сезонности Q1."                           │
└──────────────────────────────────────────────────────────────────────────────┘

Сгенерированный анализ:
┌──────────────────────────────────────────────────────────────────────────────┐
│ Сводка прогноза Apple Q1 FY2025:                                             │
│                                                                               │
│ • Выручка: $118-122 млрд (5-8% рост г/г)                                    │
│ • Валовая маржа: 45-46%                                                      │
│ • Сервисы: ожидается двузначный рост                                        │
│                                                                               │
│ Торговое значение: НЕЙТРАЛЬНО до УМЕРЕННО БЫЧЬИ                             │
│ - Прогноз соответствует консенсусу ($120 млрд)                              │
│ - Рост сервисов обеспечивает поддержку маржи                                │
│                                                                               │
│ Уверенность: 78%                                                             │
└──────────────────────────────────────────────────────────────────────────────┘
```

## Практические примеры

### 01: Система поиска документов

```python
"""
Пример 01: Построение системы поиска финансовых документов

Этот пример демонстрирует, как построить систему поиска документов
для финансовых документов с использованием эмбеддингов и векторного поиска.
"""

import numpy as np
from typing import List, Dict, Optional
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Document:
    """Финансовый документ с метаданными."""
    id: str
    text: str
    ticker: Optional[str]
    source: str
    date: datetime
    doc_type: str  # "news", "filing", "earnings", "research"

@dataclass
class SearchResult:
    """Результат поиска с оценкой релевантности."""
    document: Document
    score: float
    highlights: List[str]

class FinancialDocumentRetriever:
    """
    Система поиска финансовых документов.

    Использует семантический поиск с эмбеддингами для нахождения
    релевантных документов по запросам на естественном языке.
    """

    def __init__(self, embedding_model: str = "sentence-transformers/all-MiniLM-L6-v2"):
        self.embedding_model = embedding_model
        self.documents: List[Document] = []
        self.embeddings: Optional[np.ndarray] = None

    def add_documents(self, documents: List[Document]) -> None:
        """Добавление документов в индекс поиска."""
        # Генерация эмбеддингов для новых документов
        texts = [doc.text for doc in documents]
        new_embeddings = self._encode(texts)

        self.documents.extend(documents)
        if self.embeddings is None:
            self.embeddings = new_embeddings
        else:
            self.embeddings = np.vstack([self.embeddings, new_embeddings])

    def search(
        self,
        query: str,
        top_k: int = 5,
        ticker: Optional[str] = None,
        doc_type: Optional[str] = None
    ) -> List[SearchResult]:
        """
        Поиск релевантных документов.

        Args:
            query: Поисковый запрос на естественном языке
            top_k: Количество результатов
            ticker: Фильтр по тикеру
            doc_type: Фильтр по типу документа

        Returns:
            Список результатов поиска с оценками
        """
        # Эмбеддинг запроса
        query_embedding = self._encode([query])[0]

        # Косинусное сходство
        similarities = np.dot(self.embeddings, query_embedding) / (
            np.linalg.norm(self.embeddings, axis=1) * np.linalg.norm(query_embedding)
        )

        # Применение фильтров
        mask = np.ones(len(self.documents), dtype=bool)
        for i, doc in enumerate(self.documents):
            if ticker and doc.ticker != ticker:
                mask[i] = False
            if doc_type and doc.doc_type != doc_type:
                mask[i] = False

        similarities[~mask] = -1

        # Получение top-k результатов
        top_indices = np.argsort(similarities)[-top_k:][::-1]

        return [
            SearchResult(
                document=self.documents[idx],
                score=float(similarities[idx]),
                highlights=[]
            )
            for idx in top_indices if similarities[idx] > 0
        ]
```

### 02: Генерация торговых сигналов

```python
"""
Пример 02: Генерация торговых сигналов на основе RAG
"""

from enum import Enum

class SignalDirection(Enum):
    LONG = "LONG"       # Покупка
    SHORT = "SHORT"     # Продажа
    NEUTRAL = "NEUTRAL" # Нейтрально

@dataclass
class TradingSignal:
    """Сгенерированный торговый сигнал с обоснованием."""
    ticker: str
    direction: SignalDirection
    confidence: float  # 0-1
    reasoning: str
    sources: List[str]
    timestamp: datetime

class RAGTradingSignalGenerator:
    """
    Генерация торговых сигналов с использованием RAG.

    Объединяет поиск документов с анализом LLM для создания
    действенных торговых сигналов с объяснениями.
    """

    def generate_signal(self, ticker: str) -> TradingSignal:
        """
        Генерация торгового сигнала для тикера.

        Args:
            ticker: Символ акции

        Returns:
            Торговый сигнал с обоснованием и источниками
        """
        query = f"Какой текущий рыночный настрой и прогноз для {ticker}?"

        # Поиск релевантных документов
        results = self.retriever.search(query=query, ticker=ticker, top_k=5)

        # Анализ на основе правил
        positive_keywords = ["beat", "growth", "upgrade", "bullish", "strong"]
        negative_keywords = ["miss", "decline", "downgrade", "bearish", "weak"]

        positive_count = negative_count = 0
        for result in results:
            text_lower = result.document.text.lower()
            positive_count += sum(1 for w in positive_keywords if w in text_lower)
            negative_count += sum(1 for w in negative_keywords if w in text_lower)

        if positive_count > negative_count:
            direction = SignalDirection.LONG
            confidence = min(0.9, 0.5 + (positive_count - negative_count) * 0.1)
        elif negative_count > positive_count:
            direction = SignalDirection.SHORT
            confidence = min(0.9, 0.5 + (negative_count - positive_count) * 0.1)
        else:
            direction = SignalDirection.NEUTRAL
            confidence = 0.3

        return TradingSignal(
            ticker=ticker,
            direction=direction,
            confidence=confidence,
            reasoning=f"На основе {len(results)} документов: "
                     f"{positive_count} позитивных, {negative_count} негативных сигналов.",
            sources=[r.document.source for r in results],
            timestamp=datetime.now()
        )
```

### 03: Анализ портфеля с RAG

```python
"""
Пример 03: Анализ портфеля уровня всего портфеля с RAG
"""

@dataclass
class PortfolioPosition:
    """Позиция в портфеле."""
    ticker: str
    shares: float
    entry_price: float
    current_price: float

@dataclass
class PortfolioAnalysis:
    """Полный анализ портфеля."""
    total_value: float
    risk_assessment: str
    key_risks: List[str]
    opportunities: List[str]
    recommended_actions: List[str]

class PortfolioRAGAnalyzer:
    """
    Анализ портфеля с использованием RAG для комплексных выводов.
    """

    def analyze_portfolio(
        self,
        positions: List[PortfolioPosition]
    ) -> PortfolioAnalysis:
        """
        Выполнение комплексного анализа портфеля.

        Args:
            positions: Список позиций портфеля

        Returns:
            Полный анализ портфеля с рекомендациями
        """
        total_value = sum(pos.shares * pos.current_price for pos in positions)

        position_signals = {}
        all_risks = []
        all_opportunities = []

        for position in positions:
            signal = self.signal_generator.generate_signal(position.ticker)
            position_signals[position.ticker] = signal

            # Поиск рисков
            risk_results = self.retriever.search(
                query=f"риски и проблемы для {position.ticker}",
                ticker=position.ticker,
                top_k=3
            )
            all_risks.extend([r.document.text[:100] for r in risk_results])

            # Поиск возможностей
            opp_results = self.retriever.search(
                query=f"возможности роста для {position.ticker}",
                ticker=position.ticker,
                top_k=3
            )
            all_opportunities.extend([r.document.text[:100] for r in opp_results])

        recommendations = self._generate_recommendations(positions, position_signals)
        risk_assessment = self._assess_risk(position_signals)

        return PortfolioAnalysis(
            total_value=total_value,
            risk_assessment=risk_assessment,
            key_risks=all_risks[:5],
            opportunities=all_opportunities[:5],
            recommended_actions=recommendations
        )
```

## Реализация на Rust

Смотрите директорию `rust_rag_trading/` для полной реализации на Rust с:

- **Поддержка async/await** с Tokio для высокопроизводительного I/O
- **Векторный поиск сходства** с эффективными SIMD операциями
- **Обработка документов** с разбиением и извлечением метаданных
- **Интеграция с Bybit API** для данных криптовалют
- **Загрузка Yahoo Finance** для данных фондового рынка

```rust
// Пример использования Rust RAG реализации
use rag_trading::{
    DocumentRetriever, RAGSignalGenerator, Document,
    BybitDataLoader, YahooFinanceLoader
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Инициализация retriever
    let mut retriever = DocumentRetriever::new()?;

    // Добавление документов
    retriever.add_documents(vec![
        Document::new(
            "Tesla сообщила о рекордных поставках в Q4...",
            Some("TSLA"),
            "news",
            chrono::Utc::now()
        ),
    ]).await?;

    // Генерация сигнала
    let generator = RAGSignalGenerator::new(retriever);
    let signal = generator.generate_signal("TSLA").await?;

    println!("Сигнал: {:?}", signal);

    Ok(())
}
```

## Реализация на Python

Смотрите директорию `python/` для полной реализации на Python:

- **`retriever.py`**: Поиск документов с семантическим поиском
- **`signals.py`**: Генерация торговых сигналов
- **`backtest.py`**: Фреймворк бэктестинга
- **`data_loader.py`**: Загрузка данных Yahoo Finance и Bybit
- **`examples/`**: Демо-скрипты

## Лучшие практики

### 1. Качество документов

```
ЧЕКЛИСТ КАЧЕСТВА ДОКУМЕНТОВ:
✓ Удалите шаблонный текст (отказы от ответственности, юридический текст)
✓ Нормализуйте даты в единый формат
✓ Извлеките и проверьте тикеры
✓ Удалите дубликаты
✓ Проверьте надёжность источника
✓ Разметьте типом документа и датой
```

### 2. Стратегия разбиения

```python
# Рекомендуемые стратегии разбиения для финансовых документов
CHUNKING_STRATEGIES = {
    "news": {
        "chunk_size": 512,
        "overlap": 50,
        "strategy": "paragraph"  # По абзацам
    },
    "10-K": {
        "chunk_size": 1024,
        "overlap": 100,
        "strategy": "section"  # По разделам SEC
    },
    "earnings_call": {
        "chunk_size": 768,
        "overlap": 75,
        "strategy": "speaker"  # По спикерам
    }
}
```

### 3. Оптимизация поиска

- Используйте **гибридный поиск** (семантический + ключевые слова)
- Применяйте **фильтрацию метаданных** (дата, тикер) до семантического поиска
- Реализуйте **ре-ранжирование** для топ результатов
- Кэшируйте частые запросы

### 4. Генерация сигналов

- Всегда указывайте **атрибуцию источников**
- Включайте **оценки уверенности**
- Логируйте все генерации сигналов
- Реализуйте **размер позиции** на основе уверенности

### 5. Бэктестинг

- Используйте **out-of-sample** данные для валидации
- Учитывайте **look-ahead bias** в метках времени документов
- Включайте **транзакционные издержки**
- Тестируйте в разных **рыночных режимах**

## Ресурсы

### Научные статьи

1. **Retrieval-Augmented Generation for Large Language Models: A Survey**
   - arXiv: [2312.10997](https://arxiv.org/abs/2312.10997)
   - Комплексный обзор техник RAG

2. **REALM: Retrieval-Augmented Language Model Pre-Training**
   - arXiv: [2002.08909](https://arxiv.org/abs/2002.08909)
   - Основополагающая работа по retrieval-augmented LM

3. **FinGPT: Open-Source Financial Large Language Models**
   - arXiv: [2306.06031](https://arxiv.org/abs/2306.06031)
   - Open-source финансовый LLM с возможностями RAG

### Инструменты и библиотеки

| Инструмент | Назначение | Ссылка |
|------------|-----------|--------|
| LangChain | RAG фреймворк | [langchain.com](https://www.langchain.com/) |
| LlamaIndex | Индексация документов | [llamaindex.ai](https://www.llamaindex.ai/) |
| ChromaDB | Векторное хранилище | [trychroma.com](https://www.trychroma.com/) |
| Sentence-Transformers | Эмбеддинги | [sbert.net](https://www.sbert.net/) |
| yfinance | Данные акций | [pypi.org/project/yfinance](https://pypi.org/project/yfinance/) |

### Источники данных

- **SEC EDGAR**: Бесплатные отчёты SEC ([sec.gov/edgar](https://www.sec.gov/edgar))
- **Yahoo Finance**: Данные акций через yfinance
- **Bybit API**: Данные криптовалют
- **Alpha Vantage**: Новости и рыночные данные
- **Polygon.io**: Рыночные данные в реальном времени

---

## Заключение

RAG для трейдинга объединяет мощь LLM с поиском информации в реальном времени для создания интеллектуальных торговых систем, которые:

1. **Остаются актуальными**: Доступ к новостям и отчётам в реальном времени
2. **Обоснованы**: Анализ базируется на реальных документах
3. **Прозрачны**: Цитируют источники для всех утверждений
4. **Масштабируются**: Обновление знаний без переобучения

Ключевые выводы:
- Выбирайте подходящие **модели эмбеддингов** для финансового домена
- Реализуйте правильные **конвейеры обработки документов**
- Используйте **гибридный поиск** для лучших результатов
- Всегда **тестируйте** стратегии перед развёртыванием
- Мониторьте и **логируйте** все сигналы для постоянного улучшения

Примеры кода в этой главе предоставляют основу для создания production-ready систем RAG для торговых приложений.

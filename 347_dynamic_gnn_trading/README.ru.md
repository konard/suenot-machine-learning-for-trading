# Глава 347: Динамические графовые нейронные сети для трейдинга

## Обзор

Динамические графовые нейронные сети (Dynamic GNN) представляют собой передовой подход к моделированию финансовых рынков, улавливающий эволюционирующие связи между активами, участниками рынка и внешними факторами во времени. В отличие от статических графовых нейронных сетей, которые предполагают фиксированную структуру графа, Dynamic GNN адаптируют свою топологию и веса рёбер в ответ на изменяющиеся рыночные условия.

## Содержание

1. [Введение](#введение)
2. [Теоретические основы](#теоретические-основы)
3. [Построение динамического графа](#построение-динамического-графа)
4. [Компоненты архитектуры](#компоненты-архитектуры)
5. [Механизмы временной эволюции](#механизмы-временной-эволюции)
6. [Применение в криптовалютном трейдинге](#применение-в-криптовалютном-трейдинге)
7. [Стратегия реализации](#стратегия-реализации)
8. [Управление рисками](#управление-рисками)
9. [Метрики производительности](#метрики-производительности)
10. [Литература](#литература)

---

## Введение

Финансовые рынки — это по своей природе динамические системы, где связи между активами постоянно эволюционируют. Традиционные подходы машинного обучения часто не способны уловить эти сложные, изменяющиеся во времени взаимозависимости. Динамические GNN решают эту проблему путём:

- **Моделирования эволюционирующих корреляций**: Корреляции активов меняются в различных рыночных режимах
- **Улавливания микроструктуры рынка**: Потоки ордеров и связи ликвидности постоянно смещаются
- **Адаптации к смене режимов**: Бычий, медвежий и боковой рынки имеют разные структурные свойства
- **Изучения временных паттернов**: Движения цен следуют сложным временным зависимостям

### Почему Dynamic GNN для трейдинга?

```
┌─────────────────────────────────────────────────────────────────┐
│                    Рынок как динамический граф                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│    BTC ←──────→ ETH        Время t₁: Высокая корреляция         │
│     ↑           ↑                                                │
│     │           │                                                │
│     ↓           ↓                                                │
│   USDT ←──────→ SOL                                             │
│                                                                  │
│    ════════════════════════════════════════════                 │
│                                                                  │
│    BTC ←─ ─ ─ → ETH        Время t₂: Декорреляция               │
│     ↑                                                           │
│     │     ╲                                                      │
│     ↓      ╲                                                     │
│   USDT      → SOL          Появляются новые связи               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## Теоретические основы

### Графовое представление рынков

Финансовый рынок в момент времени $t$ может быть представлен как граф $G_t = (V, E_t, X_t)$, где:

- **V**: Множество узлов (активы, биржи, трейдеры)
- **E_t**: Изменяющиеся во времени рёбра (корреляции, потоки ордеров, арбитражные возможности)
- **X_t**: Признаки узлов (цена, объём, волатильность, глубина стакана)

### Фреймворк передачи сообщений

Основная операция GNN следует парадигме передачи сообщений:

$$h_v^{(l+1)} = \text{UPDATE}\left(h_v^{(l)}, \text{AGGREGATE}\left(\{m_{uv} : u \in \mathcal{N}(v)\}\right)\right)$$

Где:
- $h_v^{(l)}$ — скрытое состояние узла $v$ на слое $l$
- $m_{uv}$ — сообщение от узла $u$ к узлу $v$
- $\mathcal{N}(v)$ — окрестность узла $v$

### Временные графовые сети (TGN)

Для динамических графов мы расширяем это до временных графов:

$$h_v(t) = \text{GNN}\left(h_v(t^-), \{(h_u(t^-), e_{uv}(t), \Delta t_{uv}) : u \in \mathcal{N}_t(v)\}\right)$$

Где $\Delta t_{uv}$ представляет время с момента последнего взаимодействия.

## Построение динамического графа

### Графы на основе корреляций

```
Скользящая матрица корреляций → Матрица смежности → Структура графа

           BTC    ETH    SOL    AVAX
    BTC   1.00   0.85   0.72   0.68
    ETH   0.85   1.00   0.78   0.71
    SOL   0.72   0.78   1.00   0.82
    AVAX  0.68   0.71   0.82   1.00

    Порог: ρ > 0.7 создаёт ребро
```

### Графы потоков ордеров

```
┌────────────────────────────────────────────────┐
│       Построение графа потоков ордеров          │
├────────────────────────────────────────────────┤
│                                                 │
│   Биржа A ─────────→ Биржа B                    │
│       │         поток        │                  │
│       │                      │                  │
│       ↓                      ↓                  │
│   Кит-адрес ←───────── Розничный пул           │
│                                                 │
│   Вес ребра = Объём × Частота × Актуальность   │
│                                                 │
└────────────────────────────────────────────────┘
```

### Многомасштабные графы

Мы строим графы на нескольких временных масштабах:

1. **Уровень тиков** (миллисекунды): Связи микроструктуры
2. **Минутный уровень**: Краткосрочный моментум
3. **Часовой уровень**: Внутридневные паттерны
4. **Дневной уровень**: Макро-тренды

## Компоненты архитектуры

### 1. Предиктор динамических рёбер

Предсказывает, какие рёбра должны существовать в момент $t+1$:

```
Вход: Эмбеддинги узлов h_u(t), h_v(t)
      Историческое существование рёбер
      Признаки рыночного режима

Выход: P(ребро_uv существует в t+1)
```

### 2. Агрегация на основе внимания

```
α_uv = softmax(LeakyReLU(a^T [Wh_u || Wh_v || e_uv]))

h_v' = σ(Σ α_uv · Wh_u)
```

### 3. Модуль временной памяти

```
┌─────────────────────────────────────────────────┐
│              Ячейка временной памяти             │
├─────────────────────────────────────────────────┤
│                                                  │
│   Memory(t) = Memory(t-1) ⊙ forget_gate          │
│             + new_info ⊙ input_gate              │
│                                                  │
│   Где:                                           │
│   - forget_gate = σ(W_f · [h(t), Δt])           │
│   - input_gate = σ(W_i · [h(t), Δt])            │
│   - new_info = tanh(W_c · [h(t), event])        │
│                                                  │
└─────────────────────────────────────────────────┘
```

### 4. Слой эволюции графа

```
G(t+1) = GraphEvolution(G(t), market_events, time_decay)

Компоненты:
├── Добавление рёбер: Обнаружены новые корреляции
├── Удаление рёбер: Корреляции разорваны
├── Обновление весов: Изменение силы связей
└── Признаки узлов: Обновления цены/объёма
```

## Механизмы временной эволюции

### Непрерывные во времени динамические графы (CTDG)

Вместо дискретных снимков моделируем граф как непрерывный процесс:

$$\frac{dh_v}{dt} = f(h_v, \{h_u : u \in \mathcal{N}(v)\}, t)$$

### Обновления по событиям

```
Типы рыночных событий:
├── Исполнение сделки → Обновление узлов цены
├── Размещение ордера → Обновление графа стакана
├── Крупный перевод → Обновление графа отслеживания китов
├── Новость/объявление → Обновление рёбер сентимента
└── Ликвидация → Обновление рёбер распространения риска
```

### Кодирование времени

Кодирование временной информации с использованием:

$$\phi(t) = [\cos(\omega_1 t), \sin(\omega_1 t), ..., \cos(\omega_d t), \sin(\omega_d t)]$$

## Применение в криптовалютном трейдинге

### Структура рынка Bybit

```
┌─────────────────────────────────────────────────────────────┐
│                   Торговый граф Bybit                        │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Спотовые рынки        Бессрочные фьючерсы                 │
│   ┌─────────┐           ┌─────────────────┐                │
│   │ BTC/USDT│←─────────→│ BTCUSDT Perp    │                │
│   │ ETH/USDT│←─────────→│ ETHUSDT Perp    │                │
│   │ SOL/USDT│←─────────→│ SOLUSDT Perp    │                │
│   └─────────┘           └─────────────────┘                │
│        ↑                        ↑                           │
│        │    Ставка финансирования│                           │
│        └────────────────────────┘                           │
│                                                              │
│   Кросс-активные сигналы:                                   │
│   • Изменения доминации BTC → ротация альткоинов            │
│   • Расхождение ставок финанс. → арбитражные возможности    │
│   • Изменения открытого интереса → индикаторы плеча         │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Инжиниринг признаков для крипты

| Категория признаков | Признаки | Частота обновления |
|---------------------|----------|-------------------|
| Цена | OHLCV, доходность, волатильность | Реальное время |
| Стакан | Спред, глубина, дисбаланс | Реальное время |
| Финансирование | Ставка финанс., прогноз ставки | 8 часов |
| Открытый интерес | OI, изменение OI, лонг/шорт | Реальное время |
| Ончейн | Движения китов, потоки бирж | Минуты |
| Сентимент | Fear & Greed, социальный объём | Часы |

### Генерация торговых сигналов

```
┌────────────────────────────────────────────────────────────┐
│              Пайплайн генерации сигналов                    │
├────────────────────────────────────────────────────────────┤
│                                                             │
│  1. Обновление графа                                        │
│     └── Приём новых рыночных данных                        │
│         └── Обновление признаков узлов                     │
│             └── Пересчёт весов рёбер                       │
│                                                             │
│  2. Прямой проход GNN                                       │
│     └── Передача сообщений по обновлённому графу           │
│         └── Временная агрегация                            │
│             └── Генерация эмбеддингов узлов                │
│                                                             │
│  3. Извлечение сигналов                                     │
│     └── Применение голов предсказания                      │
│         ├── Направление: P(вверх), P(вниз), P(боковик)    │
│         ├── Величина: Ожидаемая доходность                 │
│         └── Уверенность: Неопределённость модели           │
│                                                             │
│  4. Размер позиции                                          │
│     └── Критерий Келли с ограничениями риска               │
│         └── Оптимизация портфеля                           │
│             └── Генерация торговых ордеров                 │
│                                                             │
└────────────────────────────────────────────────────────────┘
```

## Стратегия реализации

### Архитектура модулей

```
dynamic_gnn_trading/
├── src/
│   ├── lib.rs              # Корень библиотеки
│   ├── graph/
│   │   ├── mod.rs          # Модуль графа
│   │   ├── node.rs         # Определения узлов
│   │   ├── edge.rs         # Определения рёбер
│   │   └── dynamic.rs      # Операции динамического графа
│   ├── gnn/
│   │   ├── mod.rs          # Модуль GNN
│   │   ├── layers.rs       # Слои GNN
│   │   ├── attention.rs    # Механизмы внимания
│   │   └── temporal.rs     # Временные компоненты
│   ├── data/
│   │   ├── mod.rs          # Модуль данных
│   │   ├── bybit.rs        # Клиент API Bybit
│   │   ├── orderbook.rs    # Обработка стакана
│   │   └── features.rs     # Инжиниринг признаков
│   ├── strategy/
│   │   ├── mod.rs          # Модуль стратегии
│   │   ├── signals.rs      # Генерация сигналов
│   │   └── execution.rs    # Исполнение ордеров
│   └── utils/
│       ├── mod.rs          # Утилиты
│       └── metrics.rs      # Метрики производительности
├── examples/
│   ├── basic_gnn.rs        # Базовый пример GNN
│   ├── live_trading.rs     # Демо живой торговли
│   └── backtest.rs         # Пример бэктестинга
└── tests/
    └── integration.rs      # Интеграционные тесты
```

### Ключевые принципы проектирования

1. **Модульность**: Каждый компонент независим и тестируем
2. **Обработка в реальном времени**: Спроектировано для потоковых данных
3. **Эффективность памяти**: Инкрементальные обновления графа
4. **Типобезопасность**: Использование системы типов Rust
5. **Обработка ошибок**: Комплексные типы ошибок

## Управление рисками

### Метрики риска на основе графа

```
Модель распространения риска:

Риск узла = Локальный риск + Σ (Вес ребра × Риск соседа)

Где:
- Локальный риск = VaR + Риск ликвидности + Риск концентрации
- Вес ребра = Корреляция × Фактор заражения
- Риск соседа = Риск контрагента/кластера активов
```

### Лимиты позиций

```
┌────────────────────────────────────────┐
│          Ограничения риска             │
├────────────────────────────────────────┤
│ Макс. размер позиции: 5% портфеля      │
│ Макс. коррелированная экспозиция: 15%  │
│ Триггер макс. просадки: 10%            │
│ Лимит плеча: 3x                        │
│ Буфер ликвидации: 20%                  │
└────────────────────────────────────────┘
```

### Предохранители

1. **Скачок волатильности**: Пауза торговли если часовая vol > 3σ
2. **Разрыв корреляций**: Уменьшение размера при резком изменении структуры графа
3. **Кризис ликвидности**: Выход из позиций если спред > порога
4. **Расхождение модели**: Стоп если точность предсказаний падает

## Метрики производительности

### Метрики модели

| Метрика | Описание | Цель |
|---------|----------|------|
| AUC предсказания графа | Предсказание существования рёбер | > 0.75 |
| Точность направления | Предсказание направления цены | > 55% |
| Коэффициент Шарпа | Доходность с учётом риска | > 2.0 |
| Макс. просадка | Наибольшее падение от пика | < 15% |
| Коэффициент Кальмара | Доходность / Макс. просадка | > 1.5 |

### Требования к задержке

```
┌─────────────────────────────────────────┐
│         Бюджет задержки                 │
├─────────────────────────────────────────┤
│ Приём данных:        < 10мс             │
│ Обновление графа:    < 50мс             │
│ Инференс GNN:        < 100мс            │
│ Генерация сигнала:   < 20мс             │
│ Отправка ордера:     < 50мс             │
├─────────────────────────────────────────┤
│ Общий цикл:          < 230мс            │
└─────────────────────────────────────────┘
```

## Литература

1. Rossi, E., et al. (2020). "Temporal Graph Networks for Deep Learning on Dynamic Graphs." *ICML Workshop on Graph Representation Learning*

2. Xu, D., et al. (2020). "Inductive Representation Learning on Temporal Graphs." *ICLR*

3. Pareja, A., et al. (2020). "EvolveGCN: Evolving Graph Convolutional Networks for Dynamic Graphs." *AAAI*

4. Sankar, A., et al. (2020). "DySAT: Deep Neural Representation Learning on Dynamic Graphs via Self-Attention Networks." *WSDM*

5. Kumar, S., et al. (2019). "Predicting Dynamic Embedding Trajectory in Temporal Interaction Networks." *KDD*

6. Kazemi, S.M., et al. (2020). "Representation Learning for Dynamic Graphs: A Survey." *JMLR*

7. Chen, J., et al. (2021). "Graph Neural Networks for Financial Market Prediction." *IEEE Transactions on Neural Networks*

---

## Следующие шаги

- [Простое объяснение](readme.simple.ru.md) - Версия для начинающих
- [English Version](README.md) - Английская версия
- [Запустить примеры](examples/) - Рабочий код на Rust

---

*Глава 347 из "Машинное обучение для трейдинга"*
